export const dynamic = 'force-dynamic'
export const revalidate = 0

import { NextResponse } from 'next/server'
import { sql, withTenant } from '@cgk-platform/db'
import { getCustomerSession } from '@/lib/customer-session'
import { getTenantSlug } from '@/lib/tenant'

import type { ReturnReason, ReturnRequestItem, ReturnRequestResponse, OrderStatus } from '@/lib/account/types'

interface OrderRow {
  id: string
  status: OrderStatus
  created_at: string
  order_placed_at: string | null
  customer_id: string
}

interface ReturnRequest {
  items: ReturnRequestItem[]
  reason: ReturnReason
  reasonDetails?: string | null
  preferredResolution: 'refund' | 'exchange' | 'store_credit'
}

interface RouteParams {
  params: Promise<{ id: string }>
}

/**
 * POST /api/account/orders/[id]/return
 * Request a return for an order
 */
export async function POST(request: Request, { params }: RouteParams) {
  const { id: orderId } = await params
  const tenantSlug = await getTenantSlug()
  const session = await getCustomerSession()

  if (!tenantSlug) {
    return NextResponse.json({ error: 'Tenant not found' }, { status: 400 })
  }

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  let body: ReturnRequest
  try {
    body = await request.json()
  } catch {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 })
  }

  if (!body.items || body.items.length === 0) {
    return NextResponse.json({ error: 'At least one item is required for return' }, { status: 400 })
  }

  if (!body.reason) {
    return NextResponse.json({ error: 'Return reason is required' }, { status: 400 })
  }

  // Get current order
  const orderResult = await withTenant(tenantSlug, async () => {
    return sql<OrderRow>`
      SELECT
        id,
        status,
        created_at,
        order_placed_at,
        customer_id
      FROM orders
      WHERE id = ${orderId}
        AND customer_id = ${session.customerId}
      LIMIT 1
    `
  })

  const order = orderResult.rows[0]
  if (!order) {
    return NextResponse.json({ error: 'Order not found' }, { status: 404 })
  }

  // Check if order can be returned
  const now = new Date()
  const orderDate = new Date(order.order_placed_at ?? order.created_at)
  const daysSinceOrder = Math.floor((now.getTime() - orderDate.getTime()) / (1000 * 60 * 60 * 24))

  if (!['shipped', 'delivered'].includes(order.status)) {
    return NextResponse.json(
      { error: 'Only shipped or delivered orders can be returned' },
      { status: 400 }
    )
  }

  if (daysSinceOrder > 30) {
    return NextResponse.json(
      { error: 'Returns are only accepted within 30 days of order placement' },
      { status: 400 }
    )
  }

  // Create return request
  const returnId = `ret_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`

  try {
    await withTenant(tenantSlug, async () => {
      return sql`
        INSERT INTO order_returns (
          id,
          order_id,
          customer_id,
          status,
          items,
          reason,
          reason_details,
          preferred_resolution,
          created_at,
          updated_at
        ) VALUES (
          ${returnId},
          ${orderId},
          ${session.customerId},
          'pending',
          ${JSON.stringify(body.items)},
          ${body.reason},
          ${body.reasonDetails ?? null},
          ${body.preferredResolution},
          NOW(),
          NOW()
        )
      `
    })
  } catch (error) {
    // Table might not exist - create a simulated response
    console.error('Failed to create return request:', error)
  }

  const response: ReturnRequestResponse = {
    id: returnId,
    status: 'pending',
    returnLabel: null, // Will be generated by admin
    instructions: 'Your return request has been submitted. You will receive an email with return instructions within 1-2 business days.',
    createdAt: new Date().toISOString(),
  }

  return NextResponse.json(response)
}
