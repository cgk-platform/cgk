# Multi-Tenant E-Commerce Platform - Agent Kickoff

You are building a **multi-tenant e-commerce orchestration platform** called CGK (Commerce Growth Kit). This platform will power multiple DTC brands from a single codebase.

---

## Your First Steps

1. **Read the master plan**:
   ```
   Read file_path="/Users/holdenthemic/Documents/cgk/MULTI-TENANT-PLATFORM-PLAN/PLAN.md"
   ```

2. **Read the index** (phase dependencies, reading lists, parallelization map):
   ```
   Read file_path="/Users/holdenthemic/Documents/cgk/MULTI-TENANT-PLATFORM-PLAN/INDEX.md"
   ```

3. **Read the architecture**:
   ```
   Read file_path="/Users/holdenthemic/Documents/cgk/MULTI-TENANT-PLATFORM-PLAN/ARCHITECTURE.md"
   ```

4. **Read your assigned phase doc** from `phases/` directory

---

## Planning Docs Location

All planning docs are here:
```
/Users/holdenthemic/Documents/cgk/MULTI-TENANT-PLATFORM-PLAN/
‚îú‚îÄ‚îÄ PLAN.md                    # Master plan - START HERE
‚îú‚îÄ‚îÄ INDEX.md                   # Navigation, dependencies, reading lists
‚îú‚îÄ‚îÄ ARCHITECTURE.md            # Technical architecture
‚îú‚îÄ‚îÄ RESTRUCTURE-GUIDE.md       # Phase doc template
‚îú‚îÄ‚îÄ phases/                    # 35 phase implementation docs
‚îÇ   ‚îú‚îÄ‚îÄ PHASE-0-PORTABILITY.md
‚îÇ   ‚îú‚îÄ‚îÄ PHASE-1A-MONOREPO.md
‚îÇ   ‚îú‚îÄ‚îÄ PHASE-1B-DATABASE.md
‚îÇ   ‚îú‚îÄ‚îÄ ... (see INDEX.md for full list)
‚îÇ   ‚îî‚îÄ‚îÄ PHASE-8-AUDIT.md
‚îú‚îÄ‚îÄ CODEBASE-ANALYSIS/         # Current RAWDOG analysis (10 docs)
‚îî‚îÄ‚îÄ *-SPEC-*.md                # Feature specifications (6 docs)
```

---

## RAWDOG Reference Codebase

You are building NEW code. RAWDOG is the reference implementation to extract patterns from:
```
/Users/holdenthemic/Documents/rawdog-web/
‚îú‚îÄ‚îÄ src/trigger/       # 199 background tasks (reference for rebuild)
‚îú‚îÄ‚îÄ src/app/api/       # 1,032 API routes
‚îú‚îÄ‚îÄ src/app/admin/     # 60+ admin sections
‚îú‚îÄ‚îÄ src/components/    # 465 React components
‚îî‚îÄ‚îÄ src/lib/           # Business logic patterns
```

---

## Key Metrics

| What | Count |
|------|-------|
| Background tasks to rebuild | 199 |
| API routes in RAWDOG | 1,032 |
| MCP tools to port | 70+ |
| Health monitors to build | 15+ |
| Phase docs total | 35 |
| Final audit agents (parallel) | 15 |

---

## Core Architecture Decisions

| Decision | Choice |
|----------|--------|
| Database | Schema-per-tenant PostgreSQL |
| Background Jobs | Provider TBD (agent discretion) |
| Auth | Custom JWT (replacing Clerk) |
| Commerce | Dual: Shopify (default) + Custom+Stripe (opt-in) |
| MCP Transport | Streamable HTTP (not SSE) |
| Payments | Stripe Connect + Wise hybrid |

---

## Critical Constraints

1. **File size**: Keep files under 650 lines, split if larger
2. **Database**: Use `sql` template tag, NEVER `db.connect()`
3. **Tenant isolation**: **MANDATORY** - Read [TENANT-ISOLATION.md](./TENANT-ISOLATION.md)
4. **Type checking**: Use `npx tsc --noEmit` (not `npm run build`)
5. **No vendor lock-in**: Abstract all external services
6. **Outcome-focused**: Implement what's needed, choose best tools

---

## Tenant Isolation (MANDATORY)

**READ THIS**: [TENANT-ISOLATION.md](./TENANT-ISOLATION.md)

Every line of code must enforce isolation:

```typescript
// ‚úÖ ALWAYS use tenant context
const orders = await withTenant(tenantId, () =>
  sql`SELECT * FROM orders`
)

// ‚úÖ ALWAYS use tenant-prefixed cache
const cache = createTenantCache(tenantId)
await cache.set('config', data)

// ‚úÖ ALWAYS include tenantId in job events
await jobProvider.send('order/created', { tenantId, orderId })

// ‚ùå NEVER query without tenant context
const orders = await sql`SELECT * FROM orders`  // WRONG
```

**No exceptions. Every agent must follow these rules.**

---

## Phase Structure

Phases use sub-phase naming: `PHASE-{N}{Letter}-{TOPIC}.md`

Example flow for Phase 1:
```
PHASE-1A-MONOREPO.md   ‚Üí Week 1: Turborepo + pnpm
PHASE-1B-DATABASE.md   ‚Üí Week 2: Schema-per-tenant
PHASE-1C-AUTH.md       ‚Üí Week 3: JWT + sessions
PHASE-1D-PACKAGES.md   ‚Üí Week 4: Core packages
```

Each phase doc has:
- **Goal** - What to achieve
- **Success Criteria** - How to verify completion
- **Deliverables** - Specific outputs
- **Pattern References** - Which docs/code to reference
- **Tasks** - Marked `[PARALLEL]` or `[SEQUENTIAL]`

---

## Parallelization

Many phases can run with multiple agents simultaneously. See INDEX.md for the full map. Key parallel opportunities:

- **Week 5-7**: Brand Admin (2A-2D) || Super Admin (2SA-*)
- **Week 8**: Health (2PO-HEALTH) || Logging (2PO-LOGGING)
- **Week 19-21**: Commerce jobs || Creator jobs || Analytics jobs
- **Week 27**: 15 audit agents run simultaneously

---

## Required Skills

Before building UI components or MCP tools:
```bash
npx skills add anthropics/skills@frontend-design -g -y
npx skills add anthropics/skills@mcp-builder -g -y
```

Use Context7 MCP for library documentation lookups.
Use Shopify Dev MCP for all Shopify API work.

---

## MANDATORY: Frontend Design Skill for UI Work

**CRITICAL**: ALL UI components MUST use `/frontend-design` before implementation.

See `FRONTEND-DESIGN-SKILL-GUIDE.md` for detailed prompts per component.

### High-Intensity UI Phases

| Phase | Components |
|-------|------------|
| **2A** (Admin Shell) | Sidebar, header, dashboard, KPIs |
| **2B** (Commerce) | DataTables, filters, order detail |
| **2SA** (Super Admin) | Platform KPIs, brands grid, alert feed |
| **2PO-ONBOARDING** | 9-step wizard, OAuth flows, integrations |
| **3A-3D** (Storefront) | **CRITICAL** - Product pages, cart, checkout |
| **4A** (Creator) | Dashboard, earnings cards |

### How to Use

Before creating ANY component:
```
/frontend-design

Building [COMPONENT] for [PHASE].

Requirements:
- [List specific requirements]
- [Layout needs]
- [Interactions]

User context:
- [Who uses this?]
- [What do they need?]
```

**Never skip this for UI work.** See `FRONTEND-DESIGN-SKILL-GUIDE.md` for complete guidance.

---

## Permission Check Patterns

**CRITICAL**: All admin actions must check permissions. Use these patterns consistently.

### API Route Protection

```typescript
// apps/admin/src/app/api/creators/route.ts
import { getTenantContext } from '@cgk/auth'
import { requirePermission, hasPermission } from '@cgk/auth/permissions'
import { withTenant } from '@cgk/db'

export async function GET(req: Request) {
  const { tenantId, userId, permissions } = await getTenantContext(req)

  // OPTION 1: Middleware-style check (recommended for simple cases)
  await requirePermission(req, 'creators.view')

  // OPTION 2: Manual check with custom handling
  if (!hasPermission(permissions, 'creators.view')) {
    return Response.json(
      { error: 'Permission denied', required: 'creators.view' },
      { status: 403 }
    )
  }

  const creators = await withTenant(tenantId, async () => {
    return sql`SELECT * FROM creators ORDER BY created_at DESC`
  })

  return Response.json({ creators })
}

export async function POST(req: Request) {
  const { tenantId, permissions } = await getTenantContext(req)

  // Different permission for write operations
  if (!hasPermission(permissions, 'creators.manage')) {
    return Response.json(
      { error: 'Permission denied', required: 'creators.manage' },
      { status: 403 }
    )
  }

  // ... create creator
}
```

### React UI Permission Gates

```typescript
// Show/hide UI elements based on permissions
import { useHasPermission, PermissionGate } from '@cgk/ui/permissions'

function CreatorsPage() {
  const canManage = useHasPermission('creators.manage')
  const canApprovePayouts = useHasPermission('creators.payments.approve')

  return (
    <div>
      <h1>Creators</h1>

      {/* Conditionally show based on permission */}
      {canManage && (
        <Button>Add Creator</Button>
      )}

      {/* Or use the PermissionGate component */}
      <PermissionGate
        permission="creators.payments.approve"
        fallback={<Badge>View Only</Badge>}
      >
        <Button>Approve Payout</Button>
      </PermissionGate>
    </div>
  )
}
```

### Permission Categories Reference

```typescript
const PERMISSION_CATEGORIES = {
  // Tenant settings
  'tenant.settings.view': 'View tenant settings',
  'tenant.settings.edit': 'Edit tenant settings',
  'tenant.billing.view': 'View billing',
  'tenant.billing.manage': 'Manage billing',

  // Team management
  'team.view': 'View team members',
  'team.invite': 'Invite team members',
  'team.manage': 'Edit/remove members',
  'team.roles.manage': 'Manage custom roles',

  // Creator management
  'creators.view': 'View creators',
  'creators.manage': 'Manage creators',
  'creators.contracts.sign': 'Sign contracts',
  'creators.payments.approve': 'Approve payouts',

  // Commerce
  'orders.view': 'View orders',
  'orders.manage': 'Manage orders',
  'subscriptions.view': 'View subscriptions',
  'subscriptions.manage': 'Manage subscriptions',
  'reviews.view': 'View reviews',
  'reviews.manage': 'Manage reviews',

  // Finance
  'payouts.view': 'View payouts',
  'payouts.process': 'Process payouts',
  'treasury.view': 'View treasury',
  'treasury.approve': 'Approve transactions',
  'expenses.view': 'View expenses',
  'expenses.manage': 'Manage expenses',

  // Content
  'content.view': 'View content',
  'content.edit': 'Edit content',
  'content.publish': 'Publish content',
  'dam.view': 'View assets',
  'dam.manage': 'Manage assets',

  // Analytics
  'analytics.view': 'View analytics',
  'attribution.view': 'View attribution',
  'reports.export': 'Export reports',
}

// Wildcards: 'creators.*' grants all creators permissions
// Wildcards: '*.view' grants all view permissions
```

### Debug Mode Permissions

In debug mode (`DEBUG_BYPASS_AUTH=true`), the mock user has full permissions:

```typescript
// Debug user has admin access
const DEBUG_PERMISSIONS = ['*']  // All permissions
```

See `PHASE-2F-RBAC.md` for complete RBAC implementation details.

---

## Multi-Tenant Context Pattern

### Getting Current Context

```typescript
import { getTenantContext } from '@cgk/auth'

export async function GET(req: Request) {
  const {
    tenantId,      // Current tenant ID
    tenantSlug,    // Current tenant slug
    userId,        // Current user ID
    role,          // User's role in this tenant
    permissions,   // Array of permission strings
    allTenants,    // All tenants user can access
  } = await getTenantContext(req)

  // Use tenantId for all tenant-scoped operations
  const data = await withTenant(tenantId, () => {
    // ... queries automatically scoped to tenant
  })
}
```

### Tenant Context in React

```typescript
import { useTenant } from '@cgk/ui/tenant-provider'

function TenantHeader() {
  const {
    currentTenant,      // { id, slug, name, logoUrl }
    availableTenants,   // Array of all accessible tenants
    switchTenant,       // async (slug) => switch context
  } = useTenant()

  return (
    <TenantSwitcher
      current={currentTenant}
      available={availableTenants}
      onSwitch={switchTenant}
    />
  )
}
```

---

## Content & SEO Patterns

### Quality Scoring Pattern

```typescript
// Quality analyzer returns breakdown for each category
export interface QualityScore {
  total: number // 0-100
  seo: { score: number; max: 25; issues: string[] }
  readability: { score: number; max: 25; issues: string[] }
  eeat: { score: number; max: 25; issues: string[] }
  formatting: { score: number; max: 25; issues: string[] }
  aiModifiers: number // Bonus/penalty for AI content
}

async function calculateQualityScore(
  post: BlogPost,
  author: Author
): Promise<QualityScore> {
  const [seo, readability, eeat, formatting] = await Promise.all([
    calculateSeoScore(post),
    calculateReadabilityScore(post.content),
    calculateEeatScore(post, author),
    calculateFormattingScore(post)
  ])

  let aiModifiers = 0
  if (post.isAiGenerated) {
    if (author.isTeamAccount) aiModifiers -= 3
    if (!hasExperiencePhrases(post.content)) aiModifiers -= 4
    if (post.humanEditPercentage < 20) aiModifiers -= 10 // + BLOCK
    if (post.humanEditPercentage >= 40) aiModifiers += 5
  }

  return {
    total: Math.max(0, Math.min(100, seo.score + readability.score + eeat.score + formatting.score + aiModifiers)),
    seo, readability, eeat, formatting,
    aiModifiers
  }
}
```

### Topic Cluster Pattern

```typescript
// Cluster with pillar-spoke structure
interface TopicCluster {
  id: string
  tenantId: string
  name: string
  slug: string
  targetKeywords: string[]
  pillarPostId: string | null
  color: 'blue' | 'green' | 'purple' | 'orange' | 'red' | 'yellow' | 'pink' | 'gray'
}

// Link suggestion scoring
function calculateLinkRelevance(source: BlogPost, target: BlogPost): number {
  let score = 0

  // Cluster bonuses
  if (source.clusterId === target.clusterId) {
    score += target.isPillar ? 30 : 20
  }

  // Category bonus
  if (source.categoryId === target.categoryId) score += 15

  // Tag overlap
  const sharedTags = source.tags.filter(t => target.tags.includes(t))
  score += Math.min(25, sharedTags.length * 5)

  // Recency bonus
  const daysSinceUpdate = daysSince(target.updatedAt)
  if (daysSinceUpdate < 90) score += 5

  // Featured bonus
  if (target.featured) score += 10

  return Math.min(100, score)
}
```

### SEO Keyword Tracking Pattern

```typescript
// Sync keywords with Google Search Console
async function syncKeywordsWithGSC(tenantId: string): Promise<void> {
  const gscClient = await getGSCClient(tenantId)
  const keywords = await getTrackedKeywords(tenantId)

  const performanceData = await gscClient.searchAnalytics.query({
    siteUrl: await getTenantSiteUrl(tenantId),
    dimensions: ['query'],
    startDate: format(subDays(new Date(), 28), 'yyyy-MM-dd'),
    endDate: format(new Date(), 'yyyy-MM-dd'),
    rowLimit: 1000
  })

  for (const keyword of keywords) {
    const match = performanceData.rows?.find(r => r.keys?.[0] === keyword.keyword)
    if (match) {
      await updateKeywordMetrics(tenantId, keyword.id, {
        position: match.position,
        clicks: match.clicks,
        impressions: match.impressions,
        ctr: match.ctr
      })
      await recordDailySnapshot(tenantId, keyword.id, match)
    }
  }
}
```

### Redirect Loop Detection Pattern

```typescript
// ‚úÖ CORRECT - Prevent redirect loops before saving
async function detectRedirectLoop(
  tenantId: string,
  source: string,
  destination: string,
  maxDepth: number = 10
): Promise<boolean> {
  const visited = new Set<string>([normalizeSource(source)])
  let current = normalizeSource(destination)

  for (let i = 0; i < maxDepth; i++) {
    if (visited.has(current)) return true // Loop detected!
    visited.add(current)

    const redirect = await getRedirectBySource(tenantId, current)
    if (!redirect) break
    current = normalizeSource(redirect.destination)
  }

  return false
}

// ‚ùå WRONG - Save without checking
await createRedirect(tenantId, { source: '/a', destination: '/b' })
await createRedirect(tenantId, { source: '/b', destination: '/a' }) // Creates loop!
```

### UGC Submission Pattern

```typescript
// ‚úÖ CORRECT - Validate and upload with tenant isolation
async function handlePhotoSubmission(
  tenantId: string,
  formData: FormData
): Promise<PhotoSubmission> {
  const beforeFile = formData.get('before') as File
  const afterFile = formData.get('after') as File

  // Validate files
  if (!isValidImageType(beforeFile) || !isValidImageType(afterFile)) {
    throw new Error('Invalid file type. Only JPEG, PNG, WebP allowed.')
  }
  if (beforeFile.size > 10 * 1024 * 1024 || afterFile.size > 10 * 1024 * 1024) {
    throw new Error('File too large. Max 10MB per image.')
  }

  // Check for duplicate submission token
  const token = formData.get('token') as string
  if (token) {
    const existing = await getSubmissionByToken(tenantId, token)
    if (existing) throw new Error('Duplicate submission')
  }

  // Upload to tenant-prefixed path
  const beforeUrl = await uploadPhotoToBlob(tenantId, beforeFile, 'before')
  const afterUrl = await uploadPhotoToBlob(tenantId, afterFile, 'after')

  return await createPhotoSubmission(tenantId, {
    beforeImageUrl: beforeUrl,
    afterImageUrl: afterUrl,
    customerName: formData.get('name') as string,
    customerEmail: formData.get('email') as string,
    consentMarketing: formData.get('consent') === 'true',
    submissionToken: token
  })
}

// ‚úÖ CORRECT - Public API filters by consent and status
async function getPublicGallery(tenantId: string): Promise<PublicSubmission[]> {
  const submissions = await withTenant(tenantId, async () => {
    return sql`
      SELECT id, customer_name, before_image_url, after_image_url,
             duration_days, products_used,
             CASE WHEN consent_marketing THEN testimonial ELSE NULL END as testimonial
      FROM photo_submissions
      WHERE tenant_id = ${tenantId}
        AND status = 'approved'
      ORDER BY created_at DESC
    `
  })
  return submissions.rows
}
```

---

## Anti-Patterns to Avoid

```typescript
// ‚ùå NEVER - breaks with Neon pooling
const client = await db.connect()

// ‚úÖ ALWAYS - use sql template tag
const result = await sql`SELECT * FROM orders`

// ‚ùå NEVER - query without tenant context
const orders = await sql`SELECT * FROM orders`

// ‚úÖ ALWAYS - use withTenant wrapper
const orders = await withTenant(tenantId, () => sql`SELECT * FROM orders`)

// ‚ùå NEVER - raw cache without tenant prefix
await redis.set('config', data)

// ‚úÖ ALWAYS - use tenant cache helper
const cache = createTenantCache(tenantId)
await cache.set('config', data)

// ‚ùå NEVER - job without tenantId
await jobProvider.send('order/created', { orderId })

// ‚úÖ ALWAYS - include tenantId in every event
await jobProvider.send('order/created', { tenantId, orderId })

// ‚ùå NEVER - slow build
npm run build

// ‚úÖ ALWAYS - fast type checking
npx tsc --noEmit
```

---

## Email Queue & Communications Patterns

**CRITICAL**: All communications must be configurable per tenant. No hardcoded email content or sender addresses.

### Email Queue Database Pattern

```typescript
// Email queue table structure (per function)
CREATE TABLE review_email_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  order_id TEXT NOT NULL,
  customer_email TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
    -- pending, awaiting_delivery, scheduled, processing, sent, failed, skipped
  sequence_number INTEGER NOT NULL DEFAULT 1,
  trigger_run_id TEXT, -- For atomic claim
  attempts INTEGER DEFAULT 0,
  scheduled_at TIMESTAMPTZ,
  UNIQUE(tenant_id, order_id, sequence_number)
);
```

### Atomic Claim Pattern (CRITICAL)

```typescript
// ‚úÖ CORRECT - Atomic claim with FOR UPDATE SKIP LOCKED
export async function claimScheduledEntries(
  tenantId: string,
  runId: string,
  limit: number = 50
): Promise<QueueEntry[]> {
  return await withTenant(tenantId, async () => {
    return sql`
      UPDATE review_email_queue
      SET status = 'processing', trigger_run_id = ${runId}
      WHERE id IN (
        SELECT id FROM review_email_queue
        WHERE tenant_id = ${tenantId}
          AND status = 'scheduled'
          AND scheduled_at <= now()
        ORDER BY scheduled_at ASC
        LIMIT ${limit}
        FOR UPDATE SKIP LOCKED
      )
      RETURNING *
    `
  })
}

// ‚ùå WRONG - Race condition, multiple workers can claim same entry
const entries = await sql`SELECT * FROM queue WHERE status = 'scheduled'`
for (const entry of entries) {
  await sql`UPDATE queue SET status = 'processing' WHERE id = ${entry.id}`
  // Another worker might have already claimed it!
}
```

### Duplicate Prevention Pattern

```typescript
// ‚úÖ CORRECT - ON CONFLICT DO NOTHING for follow-up emails
export async function createFollowUpEntry(
  tenantId: string,
  orderId: string,
  sequenceNumber: number
): Promise<QueueEntry | null> {
  const result = await sql`
    INSERT INTO review_email_queue (
      tenant_id, order_id, sequence_number, status, scheduled_at
    )
    VALUES (${tenantId}, ${orderId}, ${sequenceNumber}, 'scheduled', now() + INTERVAL '3 days')
    ON CONFLICT (tenant_id, order_id, sequence_number) DO NOTHING
    RETURNING *
  `
  return result.rows[0] || null // null = already exists
}
```

### Exponential Backoff Retry

```typescript
// Get entries ready for retry with exponential backoff
export async function getRetryableEntries(tenantId: string): Promise<QueueEntry[]> {
  return await withTenant(tenantId, async () => {
    return sql`
      SELECT * FROM review_email_queue
      WHERE tenant_id = ${tenantId}
        AND status = 'failed'
        AND attempts < max_attempts
        AND last_attempt_at < now() - (INTERVAL '1 minute' * POWER(2, attempts))
      ORDER BY last_attempt_at ASC
      LIMIT 20
    `
  })
}
```

### Email Template Rendering

```typescript
// ‚úÖ CORRECT - Get tenant template, substitute variables
export async function renderEmailTemplate(options: {
  tenantId: string
  notificationType: string
  variables: Record<string, string>
}): Promise<RenderedEmail> {
  // Get tenant's custom template or fallback to default
  const template = await getTemplateForTenant(
    options.tenantId,
    options.notificationType
  )

  // Get configured sender address for this notification type
  const sender = await getSenderForNotification(
    options.tenantId,
    options.notificationType
  )

  // Substitute variables
  const subject = template.subject.replace(/\{\{(\w+)\}\}/g, (_, key) =>
    options.variables[key] || `{{${key}}}`
  )
  const bodyHtml = template.bodyHtml.replace(/\{\{(\w+)\}\}/g, (_, key) =>
    options.variables[key] || `{{${key}}}`
  )

  return {
    subject,
    bodyHtml,
    bodyText: htmlToPlainText(bodyHtml),
    senderAddress: sender.emailAddress,
    senderName: sender.displayName
  }
}

// ‚ùå WRONG - Hardcoded email content
const subject = 'How are you enjoying your product?'
const body = `Hi ${customerName}, RAWDOG here!` // Hardcoded brand!
```

### Fire-and-Forget Logging Pattern

```typescript
// ‚úÖ CORRECT - Log to communications without blocking main flow
export async function logSystemMessage(
  tenantId: string,
  contactId: string,
  message: string
): Promise<void> {
  // Fire-and-forget - errors logged but don't block
  try {
    await createMessage({
      tenantId,
      contactId,
      direction: 'outbound',
      channel: 'email',
      senderType: 'system',
      body: message,
      status: 'sent'
    })
  } catch (error) {
    console.error('Failed to log system message:', error)
    // Don't throw - main operation should continue
  }
}
```

### Inbound Email Routing Pattern

```typescript
// Route inbound emails by TO address
export async function routeInboundEmail(email: InboundEmail): Promise<void> {
  // Look up tenant by TO address
  const inboundAddress = await findInboundAddressByEmail(email.to)
  if (!inboundAddress) {
    await logUnknownInbound(email)
    return
  }

  const tenantId = inboundAddress.tenantId

  // Route by purpose
  switch (inboundAddress.purpose) {
    case 'treasury':
      await handleTreasuryApproval(tenantId, email)
      break
    case 'receipts':
      await handleReceiptForwarding(tenantId, email)
      break
    case 'support':
      await handleSupportReply(tenantId, email)
      break
    default:
      await handleGenericInbound(tenantId, email)
  }
}
```

### Communications Anti-Patterns

```typescript
// ‚ùå NEVER - Hardcoded sender addresses
const from = 'orders@rawdog.com'

// ‚úÖ ALWAYS - Get from tenant configuration
const sender = await getSenderForNotification(tenantId, 'review_request')

// ‚ùå NEVER - Hardcoded email content
const subject = 'Thanks for your purchase!'

// ‚úÖ ALWAYS - Render from tenant template
const { subject } = await renderEmailTemplate({ tenantId, notificationType, variables })

// ‚ùå NEVER - Skip queue, send directly
await resend.emails.send({ to, from, subject, html })

// ‚úÖ ALWAYS - Queue for tracking, retry, and bulk management
await queueEmail({ tenantId, orderId, templateType, scheduledAt })
```

---

## SMS Notification Patterns (Optional Channel)

**CRITICAL**: SMS is **OFF by default**. Only platform notifications, NO marketing.

### Checking SMS Availability

```typescript
// packages/communications/sms/settings.ts

export async function isSmsEnabled(tenantId: string): Promise<boolean> {
  const settings = await withTenant(tenantId, async () => {
    return sql`SELECT sms_enabled FROM tenant_sms_settings WHERE tenant_id = ${tenantId}`
  })
  return settings.rows[0]?.sms_enabled ?? false
}

export async function canSendSms(
  tenantId: string,
  phoneNumber: string,
  notificationType: string
): Promise<{ canSend: boolean; reason?: string }> {
  // Check master switch
  const smsEnabled = await isSmsEnabled(tenantId)
  if (!smsEnabled) {
    return { canSend: false, reason: 'SMS disabled for tenant' }
  }

  // Check notification type has SMS enabled
  const channelSettings = await getNotificationChannelSettings(tenantId, notificationType)
  if (!channelSettings.smsEnabled) {
    return { canSend: false, reason: 'SMS not enabled for this notification type' }
  }

  // Check opt-out
  const isOptedOut = await checkSmsOptOut(tenantId, phoneNumber)
  if (isOptedOut) {
    return { canSend: false, reason: 'Recipient opted out of SMS' }
  }

  // Check quiet hours
  const settings = await getSmsSettings(tenantId)
  if (settings.quietHoursEnabled && isQuietHours(settings)) {
    return { canSend: false, reason: 'Quiet hours - message will be queued' }
  }

  return { canSend: true }
}
```

### SMS Queue Pattern (Same as Email)

```typescript
// ‚úÖ CORRECT - Queue SMS with atomic claim
export async function queueSms(options: {
  tenantId: string
  phoneNumber: string
  notificationType: string
  variables: Record<string, string>
  scheduledAt?: Date
}): Promise<string> {
  const template = await getSmsTemplate(options.tenantId, options.notificationType)
  const content = renderSmsTemplate(template, options.variables)

  const result = await withTenant(options.tenantId, async () => {
    return sql`
      INSERT INTO sms_queue (
        tenant_id, phone_number, notification_type, content,
        character_count, segment_count, status, scheduled_at
      )
      VALUES (
        ${options.tenantId}, ${options.phoneNumber}, ${options.notificationType},
        ${content}, ${content.length}, ${calculateSegments(content)},
        'scheduled', ${options.scheduledAt || new Date()}
      )
      RETURNING id
    `
  })

  return result.rows[0].id
}
```

### TCPA Compliance Pattern

```typescript
// ‚úÖ CORRECT - Check opt-out before every send
export async function checkSmsOptOut(
  tenantId: string,
  phoneNumber: string
): Promise<boolean> {
  const result = await withTenant(tenantId, async () => {
    return sql`
      SELECT 1 FROM sms_opt_outs
      WHERE tenant_id = ${tenantId} AND phone_number = ${phoneNumber}
    `
  })
  return result.rows.length > 0
}

// ‚úÖ CORRECT - Handle STOP keyword webhook
export async function handleSmsOptOut(
  phoneNumber: string,
  tenantId: string,
  originalMessage: string
): Promise<void> {
  // Record opt-out
  await withTenant(tenantId, async () => {
    await sql`
      INSERT INTO sms_opt_outs (tenant_id, phone_number, opt_out_method, original_message)
      VALUES (${tenantId}, ${phoneNumber}, 'stop_keyword', ${originalMessage})
      ON CONFLICT (tenant_id, phone_number) DO NOTHING
    `
  })

  // Cancel pending SMS
  await withTenant(tenantId, async () => {
    await sql`
      UPDATE sms_queue
      SET status = 'skipped', skip_reason = 'recipient_opted_out', updated_at = now()
      WHERE tenant_id = ${tenantId}
        AND phone_number = ${phoneNumber}
        AND status IN ('pending', 'scheduled')
    `
  })
}
```

### SMS Anti-Patterns

```typescript
// ‚ùå NEVER - Send SMS without checking opt-out
await twilioClient.messages.create({ to, body })

// ‚úÖ ALWAYS - Check opt-out first
const canSend = await canSendSms(tenantId, phoneNumber, notificationType)
if (canSend.canSend) {
  await queueSms({ tenantId, phoneNumber, notificationType, variables })
}

// ‚ùå NEVER - Marketing SMS (OUT OF SCOPE)
await queueSms({ notificationType: 'promotional_offer', ... })
await queueSms({ notificationType: 'abandoned_cart', ... })

// ‚úÖ ONLY - Platform notifications
await queueSms({ notificationType: 'order_shipped', ... })
await queueSms({ notificationType: 'payment_available', ... })

// ‚ùå NEVER - Skip quiet hours check
await sendSmsNow(phoneNumber, content)

// ‚úÖ ALWAYS - Respect quiet hours (queue for later)
if (isQuietHours(settings)) {
  await queueSms({ scheduledAt: nextAvailableTime() })
} else {
  await queueSms({ scheduledAt: new Date() })
}
```

---

## Survey & Attribution Patterns

**CRITICAL**: Build our OWN survey system - DO NOT integrate with Fairing or other third-party survey tools.

### Survey Response Submission

```typescript
// ‚úÖ CORRECT - Prevent duplicate responses per order
export async function submitSurveyResponse(
  tenantId: string,
  data: SubmitResponseInput
): Promise<SurveyResponse> {
  return await withTenant(tenantId, async () => {
    // Check for existing response
    const existing = await sql`
      SELECT id FROM survey_responses
      WHERE tenant_id = ${tenantId}
        AND survey_id = ${data.surveyId}
        AND order_id = ${data.orderId}
        AND is_complete = TRUE
    `

    if (existing.rows.length > 0) {
      throw new Error('Survey already completed for this order')
    }

    // Create or update response
    const response = await sql`
      INSERT INTO survey_responses (
        tenant_id, survey_id, order_id, customer_id, customer_email
      )
      VALUES (
        ${tenantId}, ${data.surveyId}, ${data.orderId},
        ${data.customerId}, ${data.customerEmail}
      )
      ON CONFLICT (tenant_id, survey_id, order_id) DO UPDATE SET
        updated_at = now()
      RETURNING *
    `

    return response.rows[0]
  })
}
```

### Attribution Extraction

```typescript
// ‚úÖ CORRECT - Extract and store attribution source from survey
export async function processAttributionAnswer(
  tenantId: string,
  responseId: string,
  questionId: string,
  answer: string
): Promise<void> {
  await withTenant(tenantId, async () => {
    // Check if this is an attribution question
    const question = await sql`
      SELECT is_attribution_question FROM survey_questions
      WHERE id = ${questionId} AND is_attribution_question = TRUE
    `

    if (question.rows.length === 0) return

    // Update response with attribution source
    await sql`
      UPDATE survey_responses
      SET attribution_source = ${answer}
      WHERE id = ${responseId}
    `

    // Queue sync to attribution system
    await jobProvider.send('survey.sync-attribution', {
      tenantId,
      responseId,
      source: answer,
    })
  })
}
```

### NPS Score Calculation

```typescript
// ‚úÖ CORRECT - Calculate NPS from survey responses
export async function calculateNpsScore(
  tenantId: string,
  surveyId: string,
  options?: { startDate?: Date; endDate?: Date }
): Promise<NpsResult> {
  const result = await withTenant(tenantId, async () => {
    return sql`
      SELECT
        COUNT(*) FILTER (WHERE nps_score >= 9) as promoters,
        COUNT(*) FILTER (WHERE nps_score BETWEEN 7 AND 8) as passives,
        COUNT(*) FILTER (WHERE nps_score <= 6) as detractors,
        COUNT(*) as total
      FROM survey_responses
      WHERE tenant_id = ${tenantId}
        AND survey_id = ${surveyId}
        AND nps_score IS NOT NULL
        AND is_complete = TRUE
        ${options?.startDate ? sql`AND created_at >= ${options.startDate}` : sql``}
        ${options?.endDate ? sql`AND created_at <= ${options.endDate}` : sql``}
    `
  })

  const { promoters, passives, detractors, total } = result.rows[0]
  const npsScore = total > 0
    ? Math.round(((promoters - detractors) / total) * 100)
    : null

  return { promoters, passives, detractors, total, npsScore }
}
```

### Shopify Extension API Authentication

```typescript
// ‚úÖ CORRECT - Verify Shopify session token for survey API
export async function verifyShopifySession(
  sessionToken: string,
  shopDomain: string
): Promise<{ valid: boolean; customerId?: string }> {
  try {
    // Decode and verify JWT from Shopify
    const payload = await shopify.session.decodeSessionToken(sessionToken)

    // Verify shop domain matches
    if (payload.dest !== `https://${shopDomain}`) {
      return { valid: false }
    }

    // Extract customer ID if available
    const customerId = payload.sub?.startsWith('gid://shopify/Customer/')
      ? payload.sub.split('/').pop()
      : undefined

    return { valid: true, customerId }
  } catch (error) {
    console.error('Session verification failed:', error)
    return { valid: false }
  }
}
```

### Slack Survey Notification

```typescript
// ‚úÖ CORRECT - Send survey response to Slack
export async function sendSurveySlackNotification(
  tenantId: string,
  response: SurveyResponse,
  survey: Survey
): Promise<void> {
  const config = await getSurveySlackConfig(tenantId, survey.id)
  if (!config?.is_active) return

  // Check for low NPS alert
  if (config.notify_on_nps_low && response.nps_score !== null) {
    if (response.nps_score <= config.nps_low_threshold) {
      await sendSlackMessage({
        webhookUrl: decrypt(config.webhook_url),
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `üö® *Low NPS Alert* - Score: ${response.nps_score}/10\n` +
                    `Customer: ${response.customer_email}\n` +
                    `Order: ${response.order_id}`,
            },
          },
        ],
      })
      return
    }
  }

  // Regular completion notification
  if (config.notify_on_complete) {
    await sendSlackMessage({
      webhookUrl: decrypt(config.webhook_url),
      text: `üìä New survey response for "${survey.title}" from ${response.customer_email}`,
    })
  }
}
```

### Survey Anti-Patterns

```typescript
// ‚ùå NEVER - Allow multiple responses per order
await sql`INSERT INTO survey_responses ...`  // Without duplicate check

// ‚úÖ ALWAYS - Use ON CONFLICT or check first
await sql`
  INSERT INTO survey_responses (...)
  ON CONFLICT (tenant_id, survey_id, order_id) DO NOTHING
  RETURNING *
`

// ‚ùå NEVER - Store Slack webhook URLs in plaintext
const config = { webhook_url: 'https://hooks.slack.com/...' }

// ‚úÖ ALWAYS - Encrypt at rest
const config = { webhook_url: encrypt('https://hooks.slack.com/...') }

// ‚ùå NEVER - Skip tenant context in Shopify extension API
const response = await submitResponse(data)  // No tenantId!

// ‚úÖ ALWAYS - Derive tenant from shop domain
const tenant = await getTenantByShopifyDomain(shopDomain)
const response = await submitResponse(tenant.id, data)

// ‚ùå NEVER - Trust session token without verification
const customerId = req.body.customerId  // User could fake this

// ‚úÖ ALWAYS - Verify Shopify session token
const session = await verifyShopifySession(sessionToken, shopDomain)
if (!session.valid) throw new Error('Invalid session')
```

---

## Workflow Automation Patterns

### Workflow Engine Singleton

```typescript
// packages/admin-core/src/lib/workflow/engine.ts

class WorkflowEngine {
  private static instances: Map<string, WorkflowEngine> = new Map()
  private rules: WorkflowRule[] = []

  private constructor(private tenantId: string) {}

  static getInstance(tenantId: string): WorkflowEngine {
    if (!this.instances.has(tenantId)) {
      this.instances.set(tenantId, new WorkflowEngine(tenantId))
    }
    return this.instances.get(tenantId)!
  }

  async initialize(): Promise<void> {
    this.rules = await loadActiveRules(this.tenantId)
  }
}

// ‚úÖ CORRECT - Get engine for tenant
const engine = WorkflowEngine.getInstance(tenantId)
await engine.handleStatusChange({ entityType, entityId, oldStatus, newStatus })
```

### Condition Evaluation Pattern

```typescript
// packages/admin-core/src/lib/workflow/evaluator.ts

export function evaluateConditions(
  conditions: Condition[],
  context: EvaluationContext
): { passed: boolean; results: ConditionResult[] } {
  const results: ConditionResult[] = []

  for (const condition of conditions) {
    const actualValue = getFieldValue(condition.field, context)
    const passed = evaluateOperator(condition.operator, actualValue, condition.value)
    results.push({ condition, passed, actualValue })
  }

  // All conditions must pass (AND logic)
  return {
    passed: results.every(r => r.passed),
    results
  }
}

// Computed fields for common patterns
function getFieldValue(field: string, context: EvaluationContext): unknown {
  switch (field) {
    case 'daysSinceLastUpdate':
      return daysSince(context.entity.updatedAt)
    case 'hoursInStatus':
      return hoursSince(context.entity.statusChangedAt)
    case 'remindersSent':
      return context.state?.remindersSent ?? 0
    default:
      // Dot notation: 'entity.creator.email'
      return getNestedValue(context, field)
  }
}
```

### Template Interpolation Pattern

```typescript
// packages/admin-core/src/lib/workflow/templates.ts

export function interpolateTemplate(
  template: string,
  context: ExecutionContext
): string {
  return template.replace(/\{(\w+)\}/g, (_, key) => {
    const value = getTemplateValue(key, context)
    // Escape HTML for email bodies
    return escapeHtml(String(value ?? `{${key}}`))
  })
}

function getTemplateValue(key: string, context: ExecutionContext): unknown {
  switch (key) {
    case 'firstName': return context.contact?.firstName ?? 'there'
    case 'lastName': return context.contact?.lastName ?? ''
    case 'name': return context.contact?.name ?? 'there'
    case 'email': return context.contact?.email ?? ''
    case 'entityTitle': return context.entity?.title ?? 'Item'
    case 'entityStatus': return context.entity?.status ?? ''
    case 'adminUrl': return `${context.baseUrl}/admin/${context.entityType}/${context.entityId}`
    case 'daysSince': return daysSince(context.entity?.updatedAt)
    default: return context[key]
  }
}
```

### Approval Workflow Pattern

```typescript
// packages/admin-core/src/lib/workflow/approvals.ts

export async function executeWithApproval(
  execution: WorkflowExecution,
  rule: WorkflowRule,
  context: ExecutionContext
): Promise<void> {
  if (rule.requiresApproval) {
    // Mark as pending approval, don't execute actions yet
    await updateExecution(execution.id, {
      result: 'pending_approval',
      requiresApproval: true
    })

    // Notify approvers
    await notifyApprovers(rule.approverRole, execution)
    return
  }

  // No approval needed, execute immediately
  await executeActions(execution, rule.actions, context)
}

export async function approveExecution(
  executionId: string,
  approverId: string
): Promise<void> {
  const execution = await getExecution(executionId)
  if (execution.result !== 'pending_approval') {
    throw new Error('Execution is not pending approval')
  }

  // Update approval status
  await updateExecution(executionId, {
    approvedBy: approverId,
    approvedAt: new Date()
  })

  // Now execute the actions
  const rule = await getRule(execution.ruleId)
  const context = await buildContext(execution)
  await executeActions(execution, rule.actions, context)
}
```

### Scheduled Action Pattern

```typescript
// packages/admin-core/src/lib/workflow/scheduled.ts

export async function scheduleFollowup(
  ruleId: string,
  executionId: string,
  action: ScheduleFollowupAction,
  context: ExecutionContext
): Promise<void> {
  const scheduledFor = calculateScheduledTime(action.delay)

  await withTenant(context.tenantId, async () => {
    return sql`
      INSERT INTO scheduled_actions (
        rule_id, execution_id, entity_type, entity_id,
        action_type, action_config, scheduled_for,
        cancel_if, status
      )
      VALUES (
        ${ruleId}, ${executionId}, ${context.entityType}, ${context.entityId},
        ${action.followupAction.type}, ${JSON.stringify(action.followupAction.config)},
        ${scheduledFor}, ${JSON.stringify(action.cancelIf)}, 'pending'
      )
    `
  })
}

// Background job: Process scheduled actions
export async function processScheduledActions(tenantId: string): Promise<void> {
  const actions = await withTenant(tenantId, async () => {
    return sql`
      SELECT * FROM scheduled_actions
      WHERE status = 'pending'
        AND scheduled_for <= now()
      ORDER BY scheduled_for ASC
      LIMIT 50
      FOR UPDATE SKIP LOCKED
    `
  })

  for (const action of actions.rows) {
    // Check cancellation conditions
    const context = await buildContext(action)
    const shouldCancel = evaluateCancelConditions(action.cancel_if, context)

    if (shouldCancel) {
      await updateScheduledAction(action.id, {
        status: 'cancelled',
        cancelReason: 'Cancellation conditions met'
      })
      continue
    }

    // Execute the action
    try {
      await executeAction(action.action_type, action.action_config, context)
      await updateScheduledAction(action.id, {
        status: 'executed',
        executedAt: new Date()
      })
    } catch (error) {
      await updateScheduledAction(action.id, {
        status: 'failed',
        errorMessage: error.message
      })
    }
  }
}
```

### Smart Inbox Thread Pattern

```typescript
// packages/admin-core/src/lib/inbox/threads.ts

export async function getOrCreateThread(
  tenantId: string,
  contactId: string,
  options?: { relatedEntityType?: string; relatedEntityId?: string }
): Promise<Thread> {
  // Try to find existing open thread
  const existing = await withTenant(tenantId, async () => {
    return sql`
      SELECT * FROM communication_threads
      WHERE contact_id = ${contactId}
        AND status = 'open'
        ${options?.relatedEntityId
          ? sql`AND related_entity_id = ${options.relatedEntityId}`
          : sql``
        }
      ORDER BY updated_at DESC
      LIMIT 1
    `
  })

  if (existing.rows[0]) {
    return existing.rows[0]
  }

  // Create new thread
  return await createThread(tenantId, {
    contactId,
    relatedEntityType: options?.relatedEntityType,
    relatedEntityId: options?.relatedEntityId,
    status: 'open'
  })
}

export async function addMessageToThread(
  tenantId: string,
  threadId: string,
  message: {
    direction: 'inbound' | 'outbound'
    channel: 'email' | 'sms' | 'slack'
    body: string
    senderType: 'contact' | 'team_member' | 'system' | 'ai'
    senderId?: string
  }
): Promise<Message> {
  const result = await withTenant(tenantId, async () => {
    return sql`
      INSERT INTO communication_messages (
        thread_id, direction, channel, body,
        sender_type, sender_id, status, created_at
      )
      VALUES (
        ${threadId}, ${message.direction}, ${message.channel}, ${message.body},
        ${message.senderType}, ${message.senderId}, 'sent', now()
      )
      RETURNING *
    `
  })

  // Update thread denormalized fields
  await updateThreadLastMessage(tenantId, threadId, result.rows[0])

  return result.rows[0]
}
```

### Workflow Anti-Patterns

```typescript
// ‚ùå NEVER - Execute without tenant context
const engine = WorkflowEngine.getInstance()  // Missing tenantId!
await engine.handleStatusChange(...)

// ‚úÖ ALWAYS - Include tenant context
const engine = WorkflowEngine.getInstance(tenantId)
await engine.handleStatusChange({ tenantId, entityType, entityId, ... })

// ‚ùå NEVER - Skip condition evaluation
for (const rule of rules) {
  await executeActions(rule.actions)  // Didn't check conditions!
}

// ‚úÖ ALWAYS - Evaluate conditions first
for (const rule of rules) {
  const { passed } = evaluateConditions(rule.conditions, context)
  if (passed) {
    await executeActions(rule.actions)
  }
}

// ‚ùå NEVER - Template without escaping
const html = `<p>Hello ${context.firstName}!</p>`  // XSS risk!

// ‚úÖ ALWAYS - Escape template values
const html = `<p>Hello ${escapeHtml(context.firstName)}!</p>`

// ‚ùå NEVER - Ignore cooldowns
await executeRule(rule, entity)  // Might spam user!

// ‚úÖ ALWAYS - Check cooldown before execution
if (await isOnCooldown(rule.id, entity.id)) {
  return { skipped: true, reason: 'cooldown' }
}
await executeRule(rule, entity)
```

---

## E-Commerce Operations Patterns

See [ECOMMERCE-OPS-PATTERNS.md](./ECOMMERCE-OPS-PATTERNS.md) for detailed implementation patterns covering:
- Abandoned checkout detection and recovery
- Promo code validation and bulk generation
- Selling plan configuration
- Samples tracking
- Customer segmentation and RFM

Key anti-patterns to avoid:
```typescript
// ‚ùå NEVER - Query without tenant isolation
const checkouts = await sql`SELECT * FROM abandoned_checkouts`

// ‚úÖ ALWAYS - Include tenant context
const checkouts = await withTenant(tenantId, () =>
  sql`SELECT * FROM abandoned_checkouts WHERE tenant_id = ${tenantId}`
)

// ‚ùå NEVER - Validate promo codes locally
const isValid = localPromoCodes.includes(code)

// ‚úÖ ALWAYS - Validate via Shopify (source of truth)
const { valid } = await validatePromoCode(tenantId, code)

// ‚ùå NEVER - Hardcode sample detection tags
const isSample = order.tags.includes('ugc-sample')

// ‚úÖ ALWAYS - Use tenant-configured tags
const config = await getSamplesConfig(tenantId)
const isSample = order.tags.some(t => config.ugcTags.includes(t))
```

---

## Attribution System Patterns

### Attribution Processing Pattern

**CRITICAL**: Attribution is strictly tenant-isolated. All calculations, models, and results are per-tenant.

```typescript
// packages/attribution/src/calculator.ts

export async function attributeConversion(
  tenantId: string,
  conversionId: string
): Promise<AttributionResult[]> {
  // Load conversion with tenant context
  const conversion = await withTenant(tenantId, () =>
    getConversionById(conversionId)
  )

  if (!conversion || conversion.isAttributed) {
    return [] // Already attributed or not found
  }

  // Resolve touchpoints via identity matching
  const touchpoints = await resolveTouchpoints(tenantId, conversion)

  // Filter by window and mode
  const settings = await getAttributionSettings(tenantId)
  const filteredTouchpoints = filterTouchpoints(touchpoints, {
    window: settings.defaultWindow,
    mode: settings.attributionMode // 'clicks_only' | 'clicks_plus_views'
  })

  // Calculate all enabled models
  const results: AttributionResult[] = []
  for (const model of settings.enabledModels) {
    const credits = await calculateModel(model, filteredTouchpoints, conversion.value)
    results.push(...credits)
  }

  // Store results atomically (no transactions with Neon pooling)
  await withTenant(tenantId, async () => {
    for (const result of results) {
      await sql`
        INSERT INTO attribution_results (
          tenant_id, conversion_id, touchpoint_id, model, window,
          credit_percent, credit_cents
        )
        VALUES (${tenantId}, ${conversionId}, ${result.touchpointId},
                ${result.model}, ${result.window}, ${result.creditPercent},
                ${result.creditCents})
        ON CONFLICT (tenant_id, conversion_id, touchpoint_id, model, window)
        DO UPDATE SET credit_percent = EXCLUDED.credit_percent,
                      credit_cents = EXCLUDED.credit_cents
      `
    }

    // Mark conversion as attributed
    await sql`
      UPDATE attribution_conversions
      SET is_attributed = true, attributed_at = now()
      WHERE id = ${conversionId} AND tenant_id = ${tenantId}
    `
  })

  return results
}
```

### Identity Resolution Pattern

```typescript
// packages/attribution/src/identity.ts

export async function resolveTouchpoints(
  tenantId: string,
  conversion: Conversion
): Promise<Touchpoint[]> {
  // 1. Start with visitor ID from conversion
  const visitorTouchpoints = await withTenant(tenantId, () =>
    sql`SELECT * FROM attribution_touchpoints
        WHERE tenant_id = ${tenantId} AND visitor_id = ${conversion.visitorId}`
  )

  // 2. Resolve to customer identity via email hash
  const emailHash = hashEmail(conversion.email, tenantId) // tenant-specific pepper
  const customerIdentity = await withTenant(tenantId, () =>
    sql`SELECT * FROM customer_identities
        WHERE tenant_id = ${tenantId} AND email_hash = ${emailHash}`
  )

  // 3. Get all touchpoints from linked visitors
  if (customerIdentity) {
    const linkedTouchpoints = await withTenant(tenantId, () =>
      sql`SELECT t.* FROM attribution_touchpoints t
          JOIN visitor_devices vd ON t.visitor_id = vd.visitor_id
          JOIN customer_devices cd ON vd.device_fingerprint = cd.device_fingerprint
          WHERE cd.customer_id = ${customerIdentity.id}
            AND t.tenant_id = ${tenantId}`
    )
    return [...visitorTouchpoints, ...linkedTouchpoints]
  }

  return visitorTouchpoints
}

// ‚ö†Ô∏è CRITICAL: Use tenant-specific pepper for email hashing
export function hashEmail(email: string, tenantId: string): string {
  const pepper = process.env.HASH_PEPPER // 32+ chars, shared
  return crypto
    .createHash('sha256')
    .update(`${email.toLowerCase()}:${tenantId}:${pepper}`)
    .digest('hex')
}
```

### Attribution Model Pattern

```typescript
// packages/attribution/src/models/time-decay.ts

export function calculateTimeDecay(
  touchpoints: Touchpoint[],
  conversionValue: number,
  halfLifeHours: number = 168 // 7 days default
): AttributionCredit[] {
  if (touchpoints.length === 0) return []

  const conversionTime = touchpoints[0].conversion.createdAt

  // Calculate decay weights
  const weights = touchpoints.map(tp => {
    const hoursAgo = (conversionTime.getTime() - tp.timestamp.getTime()) / 3600000
    return Math.pow(2, -hoursAgo / halfLifeHours)
  })

  // Normalize weights to sum to 1
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)
  const normalizedWeights = weights.map(w => w / totalWeight)

  // Allocate credit
  return touchpoints.map((tp, i) => ({
    touchpointId: tp.id,
    model: 'time_decay',
    creditPercent: Math.round(normalizedWeights[i] * 100),
    creditCents: Math.round(normalizedWeights[i] * conversionValue)
  }))
}
```

### Touchpoint Capture Pattern

```typescript
// packages/attribution/src/tracking/capture.ts

export async function captureTouchpoint(
  tenantId: string,
  event: TrackingEvent
): Promise<void> {
  // Parse channel from click IDs and UTM
  const channel = parseChannel(event)

  // Extract campaign hierarchy
  const hierarchy = parseCampaignHierarchy(event)

  await withTenant(tenantId, () =>
    sql`INSERT INTO attribution_touchpoints (
      tenant_id, visitor_id, timestamp, channel, platform,
      campaign_id, adset_id, ad_id,
      fbclid, gclid, ttclid,
      utm_source, utm_medium, utm_campaign, utm_content, utm_term,
      device_type, browser, os, ip_hash
    )
    VALUES (
      ${tenantId}, ${event.visitorId}, ${event.timestamp}, ${channel.name}, ${channel.platform},
      ${hierarchy.campaignId}, ${hierarchy.adsetId}, ${hierarchy.adId},
      ${event.fbclid}, ${event.gclid}, ${event.ttclid},
      ${event.utmSource}, ${event.utmMedium}, ${event.utmCampaign},
      ${event.utmContent}, ${event.utmTerm},
      ${event.deviceType}, ${event.browser}, ${event.os}, ${hashIp(event.ip)}
    )
    ON CONFLICT DO NOTHING`
  )
}

// Parse nbt parameter (Northbeam-style)
// Format: nbt=nb:platform:network:campaignid:adgroupid:adid
function parseNbtParameter(nbt: string): CampaignHierarchy | null {
  const parts = nbt.split(':')
  if (parts.length < 6 || parts[0] !== 'nb') return null
  return {
    platform: parts[1],
    network: parts[2],
    campaignId: parts[3],
    adsetId: parts[4],
    adId: parts[5]
  }
}
```

### Attribution Anti-Patterns

```typescript
// ‚ùå NEVER - Query touchpoints without tenant
const touchpoints = await sql`SELECT * FROM attribution_touchpoints`

// ‚úÖ ALWAYS - Include tenant context
const touchpoints = await withTenant(tenantId, () =>
  sql`SELECT * FROM attribution_touchpoints WHERE tenant_id = ${tenantId}`
)

// ‚ùå NEVER - Share email hash salt across tenants
const hash = crypto.createHash('sha256').update(email + SALT).digest('hex')

// ‚úÖ ALWAYS - Use tenant-specific pepper
const hash = hashEmail(email, tenantId)

// ‚ùå NEVER - Train ML models on cross-tenant data
const allData = await sql`SELECT * FROM attribution_results`
const model = trainShapleyModel(allData)

// ‚úÖ ALWAYS - Train per-tenant models
const tenantData = await withTenant(tenantId, () =>
  sql`SELECT * FROM attribution_results WHERE tenant_id = ${tenantId}`
)
const model = trainShapleyModel(tenantData)
await saveModel(tenantId, model)

// ‚ùå NEVER - Hardcode attribution defaults
const results = await calculateTimeDecay(touchpoints, 168) // hardcoded half-life

// ‚úÖ ALWAYS - Use tenant settings
const settings = await getAttributionSettings(tenantId)
const results = await calculateTimeDecay(touchpoints, settings.timeDecayHalfLifeHours)
```

---

## Creator Analytics Patterns

### Pre-Aggregated Snapshots

**CRITICAL**: Dashboard analytics MUST use pre-aggregated data, not real-time queries.

```typescript
// ‚úÖ CORRECT - Use pre-aggregated snapshot for dashboard
export async function getCreatorOverviewKPIs(
  tenantId: string,
  period: '7d' | '30d' | '90d' | '12m'
): Promise<CreatorKPIs> {
  const snapshot = await withTenant(tenantId, async () => {
    return sql`
      SELECT * FROM creator_analytics_snapshots
      WHERE tenant_id = ${tenantId}
        AND snapshot_type = 'daily'
        AND snapshot_date = CURRENT_DATE - INTERVAL '1 day'
    `
  })

  const previousSnapshot = await getPreviousPeriodSnapshot(tenantId, period)

  return {
    totalCreators: snapshot.total_creators,
    activeCreators: snapshot.active_creators,
    changeFromPrevious: calculateChange(snapshot, previousSnapshot),
    // ...
  }
}

// ‚ùå WRONG - Real-time query for dashboard
export async function getCreatorOverviewKPIs(tenantId: string) {
  // This is SLOW for large datasets
  const total = await sql`SELECT COUNT(*) FROM creators WHERE tenant_id = ${tenantId}`
  const active = await sql`SELECT COUNT(*) FROM creators WHERE last_activity_at > NOW() - INTERVAL '30 days'`
  // ... more slow queries
}
```

### Health Score Calculation

```typescript
// packages/admin-core/src/lib/creators/health.ts

export function calculateCreatorHealthScore(metrics: CreatorMetrics): number {
  const weights = {
    activity: 0.30,    // Projects in last 30 days
    earnings: 0.20,    // Earnings trend (growing = high score)
    response: 0.20,    // Message response time
    delivery: 0.20,    // On-time delivery rate
    engagement: 0.10,  // Portal activity
  }

  const scores = {
    activity: calculateActivityScore(metrics.projectsLast30d, metrics.avgProjectsPerMonth),
    earnings: calculateEarningsScore(metrics.earningsTrend),
    response: calculateResponseScore(metrics.avgResponseHours),
    delivery: calculateDeliveryScore(metrics.onTimeDeliveryRate),
    engagement: calculateEngagementScore(metrics.loginCountLast30d, metrics.filesUploadedLast30d),
  }

  return Object.entries(weights).reduce(
    (total, [key, weight]) => total + scores[key as keyof typeof scores] * weight,
    0
  )
}

export function categorizeHealth(score: number): CreatorHealthCategory {
  if (score >= 90) return 'champion'
  if (score >= 70) return 'healthy'
  if (score >= 50) return 'at_risk'
  if (score >= 30) return 'inactive'
  return 'churned'
}
```

### Metrics Aggregation Job Pattern

```typescript
// packages/jobs/src/creators/aggregate-daily-metrics.ts

export const aggregateCreatorDailyMetrics = inngest.createFunction(
  { id: 'aggregate-creator-daily-metrics' },
  { cron: '0 3 * * *' }, // 3 AM daily
  async ({ step }) => {
    const tenants = await step.run('get-tenants', async () => {
      return getAllActiveTenants()
    })

    for (const tenant of tenants) {
      await step.run(`aggregate-${tenant.id}`, async () => {
        await withTenant(tenant.id, async () => {
          // 1. Calculate per-creator response metrics
          await sql`
            INSERT INTO creator_response_metrics (
              tenant_id, creator_id, metric_date,
              messages_received, messages_responded, avg_response_time_minutes,
              projects_started, projects_submitted, projects_approved
            )
            SELECT
              ${tenant.id},
              c.id,
              CURRENT_DATE - 1,
              COUNT(m.id) FILTER (WHERE m.direction = 'inbound'),
              COUNT(m.id) FILTER (WHERE m.direction = 'outbound'),
              AVG(EXTRACT(EPOCH FROM (response.created_at - m.created_at)) / 60)::INTEGER,
              COUNT(p.id) FILTER (WHERE DATE(p.created_at) = CURRENT_DATE - 1),
              COUNT(p.id) FILTER (WHERE DATE(p.submitted_at) = CURRENT_DATE - 1),
              COUNT(p.id) FILTER (WHERE DATE(p.approved_at) = CURRENT_DATE - 1)
            FROM creators c
            LEFT JOIN messages m ON m.creator_id = c.id AND DATE(m.created_at) = CURRENT_DATE - 1
            LEFT JOIN projects p ON p.creator_id = c.id
            GROUP BY c.id
            ON CONFLICT (tenant_id, creator_id, metric_date)
              DO UPDATE SET
                messages_received = EXCLUDED.messages_received,
                messages_responded = EXCLUDED.messages_responded,
                updated_at = NOW()
          `

          // 2. Create daily snapshot
          await createDailySnapshot(tenant.id)
        })
      })
    }
  }
)
```

### Analytics Anti-Patterns

```typescript
// ‚ùå NEVER - Real-time aggregation for dashboards
const topEarners = await sql`
  SELECT creator_id, SUM(amount) as total
  FROM payouts
  WHERE created_at > NOW() - INTERVAL '30 days'
  GROUP BY creator_id
  ORDER BY total DESC
  LIMIT 10
`  // This is SLOW with millions of rows!

// ‚úÖ ALWAYS - Use pre-computed leaderboard
const topEarners = await sql`
  SELECT * FROM creator_performance_leaderboard
  WHERE tenant_id = ${tenantId}
    AND metric = 'earnings'
    AND period = '30d'
  ORDER BY rank ASC
  LIMIT 10
`

// ‚ùå NEVER - Calculate health score on every request
const creators = await sql`SELECT * FROM creators`
return creators.map(c => ({
  ...c,
  healthScore: calculateHealthScore(c) // Expensive!
}))

// ‚úÖ ALWAYS - Pre-compute health scores in background job
const creators = await sql`
  SELECT c.*, s.health_score, s.health_category
  FROM creators c
  JOIN creator_health_scores s ON s.creator_id = c.id
`
```

---

## Financial Operations Patterns

### Expense Category Types

All expenses are classified by type for P&L organization:

```typescript
type ExpenseCategoryType = 'cogs' | 'variable' | 'marketing' | 'operating' | 'other'

interface ExpenseCategory {
  id: string
  tenantId: string
  name: string
  type: ExpenseCategoryType
  isActive: boolean
  displayOrder: number
}
```

### Unified Expense Query Pattern

Aggregate expenses from all sources for a date range:

```typescript
async function getUnifiedExpenses(
  tenantId: string,
  startDate: Date,
  endDate: Date,
  source?: 'ad_spend' | 'creator_payouts' | 'vendor_payouts' | 'operating'
) {
  // Always pass tenantId - data is isolated per tenant
  const [adSpend, creatorPayouts, vendorPayouts, operating] = await Promise.all([
    !source || source === 'ad_spend'
      ? getAdSpendByDateRange(tenantId, startDate, endDate) : [],
    !source || source === 'creator_payouts'
      ? getCreatorPayouts(tenantId, startDate, endDate, 'cash_only') : [],
    !source || source === 'vendor_payouts'
      ? getVendorPayouts(tenantId, startDate, endDate) : [],
    !source || source === 'operating'
      ? getOperatingExpenses(tenantId, startDate, endDate) : [],
  ])

  return normalizeToUnifiedFormat([...adSpend, ...creatorPayouts, ...vendorPayouts, ...operating])
}
```

### P&L Calculation Pattern

Standard accounting P&L with expandable categories:

```typescript
interface PLStatement {
  period: { start: Date; end: Date }
  comparison?: { start: Date; end: Date }

  revenue: {
    grossSales: number
    discounts: number
    returns: number
    shippingRevenue: number
    netRevenue: number  // grossSales - discounts - returns + shipping
  }

  cogs: {
    productCost: number
    grossProfit: number      // netRevenue - productCost
    grossMarginPercent: number
  }

  variableCosts: {
    paymentProcessing: number  // 2.9% + $0.30 per transaction
    shipping: number           // From 3PL or estimates
    fulfillment: number        // Estimates
    total: number
    contributionMargin: number // grossProfit - total
  }

  marketing: {
    adSpend: { meta: number; google: number; tiktok: number; total: number }
    creatorPayouts: number
    total: number
    contributionProfit: number // contributionMargin - total
  }

  operating: {
    byCategory: Record<string, { name: string; total: number; items: ExpenseItem[] }>
    vendorPayouts: number
    contractorPayouts: number
    total: number
    operatingIncome: number // contributionProfit - total
  }

  netProfit: number
  netMarginPercent: number
}

// ‚úÖ ALWAYS - Store amounts as cents (integer)
const amountCents = Math.round(amountDollars * 100)

// ‚úÖ ALWAYS - Calculate percentages from cents
const marginPercent = (grossProfitCents / netRevenueCents) * 100
```

### P&L Toggle Pattern

Allow excluding specific expenses from P&L:

```typescript
// Each expense can be toggled for P&L inclusion
interface ExpenseWithPnlToggle {
  id: string
  tenantId: string
  amountCents: number
  countForPnl: boolean
  pnlExclusionReason?: string  // Required when countForPnl = false
}

// ‚úÖ CORRECT - Check toggle before including in P&L
const pnlExpenses = expenses.filter(e => e.countForPnl)

// ‚ùå WRONG - Ad spend is ALWAYS included (no toggle)
// Ad spend from Meta/Google/TikTok is never excludable
```

### Treasury Draw Request Pattern

Bundle pending payouts for approval:

```typescript
interface TreasuryDrawRequest {
  id: string
  tenantId: string
  requestNumber: string  // Auto-generated: DR-2024-001
  description: string
  totalAmountCents: number
  treasurerName: string
  treasurerEmail: string
  signers: string[]
  dueDate?: Date
  pdfUrl?: string
  status: 'pending' | 'approved' | 'rejected' | 'cancelled'

  // Approval metadata
  approvedAt?: Date
  approvedBy?: string
  approvalMessage?: string
  rejectedAt?: Date
  rejectedBy?: string
  rejectionReason?: string
}

// Create from pending payouts
async function createDrawRequest(tenantId: string, withdrawalIds: string[]) {
  const withdrawals = await getPendingWithdrawals(tenantId, withdrawalIds)
  const total = withdrawals.reduce((sum, w) => sum + w.netAmountCents, 0)

  const request = await insertDrawRequest({
    tenantId,
    requestNumber: await generateRequestNumber(tenantId),
    totalAmountCents: total,
    status: 'pending',
    // ... other fields from settings
  })

  // Create line items
  for (const w of withdrawals) {
    await insertDrawRequestItem({ requestId: request.id, withdrawalId: w.id, ... })
  }

  // Generate PDF and send email
  const pdfUrl = await generateDrawRequestPdf(request)
  await sendTreasuryApprovalEmail(request, pdfUrl)

  return request
}
```

### Email Approval Parsing Pattern

Parse treasurer email replies for approval/rejection:

```typescript
const APPROVAL_KEYWORDS = ['approved', 'approve', 'yes', 'ok', 'confirmed', 'accept']
const REJECTION_KEYWORDS = ['rejected', 'reject', 'no', 'denied', 'deny', 'decline']

interface ParsedApproval {
  status: 'approved' | 'rejected' | 'unclear'
  confidence: 'high' | 'medium' | 'low'
  matchedKeywords: string[]
  extractedMessage?: string
}

function parseApprovalEmail(body: string): ParsedApproval {
  const lowerBody = body.toLowerCase()
  const approvalMatches = APPROVAL_KEYWORDS.filter(k => lowerBody.includes(k))
  const rejectionMatches = REJECTION_KEYWORDS.filter(k => lowerBody.includes(k))

  // High confidence: clear match with no conflicting keywords
  if (approvalMatches.length > 0 && rejectionMatches.length === 0) {
    return { status: 'approved', confidence: 'high', matchedKeywords: approvalMatches }
  }
  if (rejectionMatches.length > 0 && approvalMatches.length === 0) {
    return { status: 'rejected', confidence: 'high', matchedKeywords: rejectionMatches }
  }

  // Medium/low confidence if mixed signals
  return { status: 'unclear', confidence: 'low', matchedKeywords: [...approvalMatches, ...rejectionMatches] }
}
```

### Stripe Top-up Pattern

Manage platform balance:

```typescript
async function createTopup(
  tenantId: string,
  amountCents: number,
  sourceId: string,
  linkedWithdrawalIds?: string[]
) {
  const stripe = await getStripeClient(tenantId)

  const topup = await stripe.topups.create({
    amount: amountCents,
    currency: 'usd',
    source: sourceId,
    description: `Top-up for pending withdrawals`,
  })

  // Track locally
  await insertTopup({
    tenantId,
    stripeTopupId: topup.id,
    amountCents,
    status: topup.status,
    linkedWithdrawalIds,
  })

  return topup
}

// Get balance with pending indicator
async function getBalanceWithPending(tenantId: string) {
  const stripe = await getStripeClient(tenantId)
  const balance = await stripe.balance.retrieve()
  const pendingWithdrawals = await getPendingWithdrawalTotal(tenantId)

  return {
    available: balance.available[0]?.amount ?? 0,
    pending: balance.pending[0]?.amount ?? 0,
    pendingWithdrawals,
    effectiveAvailable: (balance.available[0]?.amount ?? 0) - pendingWithdrawals,
  }
}
```

### Gift Card Transaction Pattern

Process gift card rewards on qualifying orders:

```typescript
async function processGiftCardReward(tenantId: string, order: ShopifyOrder) {
  // 1. Detect gift card variant in order
  const giftCardProducts = await getActiveGiftCardProducts(tenantId)
  const giftCardItem = order.line_items.find(item =>
    giftCardProducts.some(gc => gc.variantIdNumeric === item.variant_id.toString())
  )

  if (!giftCardItem) return null

  const product = giftCardProducts.find(gc =>
    gc.variantIdNumeric === giftCardItem.variant_id.toString()
  )!

  // 2. Validate minimum order threshold
  const subtotalCents = Math.round(parseFloat(order.subtotal_price) * 100)
  if (subtotalCents < product.minOrderSubtotalCents) {
    return { skipped: true, reason: 'below_minimum' }
  }

  // 3. Create transaction (idempotent by order + variant)
  const txId = `${tenantId}_${order.id}_${product.variantId}`
  const existing = await getTransaction(txId)
  if (existing) return { skipped: true, reason: 'already_processed' }

  const transaction = await insertTransaction({
    id: txId,
    tenantId,
    shopifyOrderId: order.id.toString(),
    shopifyOrderName: order.name,
    shopifyCustomerId: order.customer.id.toString(),
    customerEmail: order.customer.email,
    amountCents: product.amountCents,
    status: 'pending',
    source: 'bundle_builder',
  })

  // 4. Issue store credit via Shopify Customer API
  try {
    await issueShopifyStoreCredit(tenantId, order.customer.id, product.amountCents)
    await updateTransaction(txId, { status: 'credited', creditedAt: new Date() })
    await queueGiftCardEmail(transaction)
  } catch (error) {
    await updateTransaction(txId, { status: 'failed', errorMessage: error.message })
  }

  return transaction
}
```

### Financial Data Isolation (CRITICAL)

```typescript
// ‚úÖ ALWAYS - Include tenant_id in all financial tables
CREATE TABLE operating_expenses (
  id UUID PRIMARY KEY,
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  ...
)

// ‚úÖ ALWAYS - Use withTenant for all queries
const expenses = await withTenant(tenantId, async () => {
  return sql`SELECT * FROM operating_expenses WHERE tenant_id = ${tenantId}`
})

// ‚úÖ ALWAYS - Log financial mutations for audit
await logAuditEvent({
  tenantId,
  userId,
  action: 'expense.create',
  resourceType: 'operating_expense',
  resourceId: expense.id,
  details: { amountCents: expense.amountCents },
})
```

### Financial Anti-Patterns

```typescript
// ‚ùå NEVER - Store amounts as floats (precision loss)
const amount = 19.99  // WRONG
const amount = 1999   // CORRECT (cents)

// ‚ùå NEVER - Calculate P&L without tenant scope
const allExpenses = await sql`SELECT * FROM expenses`  // WRONG - no tenant filter

// ‚ùå NEVER - Hardcode ad spend (comes from external sync)
const metaSpend = 5000  // WRONG
const metaSpend = await getMetaAdSpend(tenantId, dateRange)  // CORRECT

// ‚ùå NEVER - Skip audit logging for financial changes
await updateExpense(id, data)  // WRONG - no audit trail
await updateExpenseWithAudit(id, data, userId)  // CORRECT

// ‚ùå NEVER - Allow duplicate gift card transactions
// Transaction ID = tenantId + orderId + variantId (idempotency key)

// ‚ùå NEVER - Auto-approve treasury requests
// Treasury always requires explicit email-based approval
```

---

## Contractor Portal Patterns

**CRITICAL**: Contractors are single-tenant (unlike creators who work across brands). All contractor data lives in tenant schema. See [PAYEE-TYPE-MODEL-SPEC.md](./PAYEE-TYPE-MODEL-SPEC.md) for complete comparison.

### Contractor vs Creator Data Location

```typescript
// Creators: public schema (cross-tenant)
// public.creators
// public.creator_brand_memberships

// Contractors: tenant schema (single-tenant)
// {tenant_schema}.contractors
// {tenant_schema}.contractor_projects
```

### Project Kanban Status Transitions

```typescript
// 6-stage Kanban pipeline
type ProjectStatus =
  | 'pending_contractor'   // Upcoming - not started
  | 'draft'                // Upcoming - contractor drafting
  | 'in_progress'          // In Progress
  | 'submitted'            // Submitted for review
  | 'revision_requested'   // Revisions needed
  | 'approved'             // Approved
  | 'payout_ready'         // Ready for payout
  | 'withdrawal_requested' // Contractor requested payout
  | 'payout_approved'      // Payout processed

const KANBAN_COLUMNS = {
  upcoming: ['pending_contractor', 'draft'],
  inProgress: ['in_progress'],
  submitted: ['submitted'],
  revisions: ['revision_requested'],
  approved: ['approved'],
  payouts: ['payout_ready', 'withdrawal_requested', 'payout_approved'],
}

// ‚úÖ CORRECT - Validate transition before allowing
export async function updateProjectStatus(
  projectId: string,
  newStatus: ProjectStatus,
  actorType: 'contractor' | 'admin'
): Promise<void> {
  const project = await getProject(projectId)

  // Contractor transitions
  const CONTRACTOR_TRANSITIONS = {
    pending_contractor: ['draft', 'in_progress'],
    draft: ['in_progress'],
    in_progress: ['submitted'],
    revision_requested: ['in_progress', 'submitted'],
    payout_ready: ['withdrawal_requested'],
  }

  // Admin transitions
  const ADMIN_TRANSITIONS = {
    submitted: ['approved', 'revision_requested'],
    approved: ['payout_ready'],
    withdrawal_requested: ['payout_approved'],
  }

  const allowed = actorType === 'contractor'
    ? CONTRACTOR_TRANSITIONS[project.status] || []
    : ADMIN_TRANSITIONS[project.status] || []

  if (!allowed.includes(newStatus)) {
    throw new Error(`Cannot transition from ${project.status} to ${newStatus}`)
  }

  await withTenant(project.tenantId, async () => {
    await sql`
      UPDATE contractor_projects
      SET status = ${newStatus}, updated_at = NOW()
      WHERE id = ${projectId}
    `
  })
}
```

### Invoice/Payment Request Pattern

```typescript
// ‚úÖ CORRECT - Create payment request with validation
export async function createPaymentRequest(
  payeeId: string,
  tenantId: string,
  request: CreatePaymentRequestInput
): Promise<PaymentRequest> {
  // Validate amount minimum ($10)
  if (request.amountCents < 1000) {
    throw new Error('Amount must be at least $10')
  }

  // Check pending limit (max 3)
  const pendingCount = await getPendingPaymentRequestCount(payeeId)
  if (pendingCount >= 3) {
    throw new Error('Maximum 3 pending requests allowed')
  }

  return await sql`
    INSERT INTO payee_payment_requests (
      payee_id, tenant_id, amount_cents, description,
      work_type, project_id, attachments, status
    ) VALUES (...)
    RETURNING *
  `
}

// ‚úÖ CORRECT - Approve and credit balance atomically
export async function approvePaymentRequest(
  requestId: string,
  approvedAmountCents: number
): Promise<void> {
  const request = await getPaymentRequest(requestId)

  await withTenant(request.tenantId, async () => {
    // Update request status
    await sql`
      UPDATE payee_payment_requests
      SET status = 'approved', approved_amount_cents = ${approvedAmountCents}
      WHERE id = ${requestId}
    `

    // Create balance transaction (REQUIRED)
    await sql`
      INSERT INTO payee_balance_transactions (
        payee_id, tenant_id, amount_cents,
        transaction_type, status, reference_id, reference_type
      ) VALUES (
        ${request.payeeId}, ${request.tenantId}, ${approvedAmountCents},
        'earnings', 'completed', ${requestId}, 'payment_request'
      )
    `
  })
}
```

### Contractor Portal Anti-Patterns

```typescript
// ‚ùå NEVER - Store contractors in public schema
await sql`INSERT INTO public.contractors ...`  // WRONG
await withTenant(tenantId, () => sql`INSERT INTO contractors ...`)  // CORRECT

// ‚ùå NEVER - Allow contractors to skip project stages
await updateProjectStatus(id, 'approved', 'contractor')  // WRONG

// ‚ùå NEVER - Approve payment without balance transaction
await sql`UPDATE ... SET status = 'approved' ...`  // WRONG - no balance credit

// ‚ùå NEVER - Allow payout without W-9 (US contractors)
if (requiresW9(payeeId) && !hasW9(payeeId)) {
  throw new Error('W-9 required before payout')
}
```

---

## Third-Party Integration Patterns

### Platform-Level vs Tenant-Level Integrations

**Platform-level** (single config for all tenants):
- **Sentry** - Error tracking
- **Better Stack** - Uptime monitoring
- **Microsoft Clarity** - Client-side analytics (can be tenant-scoped via tags)

**Tenant-level** (each tenant configures their own):
- **Plaid** - Bank verification (per-tenant API keys)
- **PayPal** - Payouts (per-tenant OAuth credentials)
- **ElevenLabs** - TTS (shared or per-tenant API key)
- **Lob** - Physical mail (per-tenant API key)
- **Fairing** - Surveys (per-tenant API key)

### Plaid Integration Pattern

```typescript
// ‚úÖ CORRECT - Plaid Link token with tenant context
export async function createPlaidLinkToken(params: {
  tenantId: string
  userId: string
  userName: string
}): Promise<PlaidLinkToken> {
  const config = await getTenantPlaidConfig(params.tenantId)

  const response = await fetch(`${PLAID_API_URL}/link/token/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      client_id: config.clientId,
      secret: config.secret,
      client_name: config.brandName,  // Tenant's brand name
      user: { client_user_id: params.userId, legal_name: params.userName },
      products: ['auth'],
      country_codes: ['US'],
      language: 'en',
    }),
  })

  const data = await response.json()
  return { linkToken: data.link_token, expiration: data.expiration }
}

// ‚úÖ CORRECT - Store bank account with tenant isolation
export async function saveBankAccount(params: {
  tenantId: string
  creatorId: string
  accessToken: string
  itemId: string
  bankName: string
  accountLastFour: string
}): Promise<void> {
  // Store encrypted in tenant schema
  await withTenant(params.tenantId, async () => {
    await sql`
      INSERT INTO creator_payment_methods (
        creator_id, type, plaid_access_token, plaid_item_id,
        bank_name, account_last_four, verification_status
      ) VALUES (
        ${params.creatorId}, 'bank_account', ${encrypt(params.accessToken)},
        ${params.itemId}, ${params.bankName}, ${params.accountLastFour}, 'verified'
      )
    `
  })
}
```

### PayPal Payout Pattern

```typescript
// ‚úÖ CORRECT - PayPal payout with tenant context
export async function createPayPalPayout(params: {
  tenantId: string
  paypalEmail: string
  amountCents: number
  withdrawalRequestId: string
  note?: string
}): Promise<PayPalPayoutResult> {
  const accessToken = await getPayPalAccessToken(params.tenantId)

  const payload = {
    sender_batch_header: {
      sender_batch_id: params.withdrawalRequestId,
      email_subject: 'You have received a payment',  // Customizable per tenant
      email_message: params.note || 'Your payment has been processed.',
    },
    items: [{
      recipient_type: 'EMAIL',
      amount: { value: (params.amountCents / 100).toFixed(2), currency: 'USD' },
      receiver: params.paypalEmail,
      sender_item_id: params.withdrawalRequestId,
    }],
  }

  const response = await fetch(`${PAYPAL_API_URL}/v1/payments/payouts`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(payload),
  })

  return response.json()
}
```

### Webhook Handler Pattern (Lob Example)

```typescript
// ‚úÖ CORRECT - Webhook with signature verification and tenant lookup
export async function POST(request: NextRequest) {
  const signature = request.headers.get('lob-signature')
  const body = await request.text()

  // Verify signature (platform-level secret)
  if (!verifyLobSignature(body, signature, process.env.LOB_WEBHOOK_SECRET!)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 })
  }

  const event = JSON.parse(body)
  const letterId = event.body?.id

  // Look up tenant by letter ID (stored when letter was created)
  const tenantId = await getTenantByLobLetterId(letterId)
  if (!tenantId) {
    return NextResponse.json({ received: true })  // Unknown letter, ignore
  }

  // Update status within tenant context
  await withTenant(tenantId, async () => {
    await updateMailStatus(letterId, mapLobStatus(event.event_type.id))
  })

  return NextResponse.json({ received: true })
}
```

### Uptime Monitoring Pattern (Better Stack)

```typescript
// ‚úÖ CORRECT - Better Stack webhook processing (platform-level)
export async function processBetterStackWebhook(
  eventType: BetterStackEventType,
  payload: BetterStackWebhookPayload
): Promise<{ success: boolean; alertId?: string }> {
  const { data } = payload
  const monitorName = data.attributes.name || 'Unknown Monitor'

  if (eventType === 'incident.started') {
    // Store incident in ops table (not tenant-scoped)
    await sql`
      INSERT INTO ops_uptime_incidents (
        external_id, provider, monitor_name, status, started_at
      ) VALUES (${data.id}, 'betterstack', ${monitorName}, 'started', NOW())
    `

    // Create platform alert
    const alert = await createAlert({
      alertType: `uptime_incident_${data.id}`,
      severity: 'p1',
      title: `[DOWN] ${monitorName}`,
      source: 'health_check',
    })

    // Notify all affected tenants if monitor is tenant-specific
    // Or notify platform ops if platform-wide monitor

    return { success: true, alertId: alert.id }
  }

  return { success: true }
}
```

### Error Tracking Pattern (Sentry)

```typescript
// ‚úÖ CORRECT - Capture error with tenant context
export async function captureError(
  error: Error,
  context?: {
    tenantId?: string
    userId?: string
    type?: ErrorType
  }
): Promise<string | undefined> {
  const eventId = Sentry.captureException(error, {
    tags: {
      tenant_id: context?.tenantId,  // Tag for filtering in Sentry
      type: context?.type || 'api',
    },
    user: context?.userId ? { id: context.userId } : undefined,
  })

  // Also sync to ops dashboard for platform monitoring
  try {
    await createOrUpdateError({
      type: context?.type || 'api',
      message: error.message,
      stackTrace: error.stack,
      metadata: { sentryEventId: eventId, tenantId: context?.tenantId },
    })
  } catch (dbError) {
    console.error('[Sentry] Failed to sync to ops dashboard:', dbError)
  }

  return eventId
}
```

### Integration Anti-Patterns

```typescript
// ‚ùå NEVER - Hardcode API credentials
const PLAID_SECRET = 'sk_live_xxx'

// ‚úÖ ALWAYS - Get from tenant configuration or env
const config = await getTenantPlaidConfig(tenantId)

// ‚ùå NEVER - Process webhook without signature verification
export async function POST(req: Request) {
  const event = await req.json()  // DANGEROUS!
  await processEvent(event)
}

// ‚úÖ ALWAYS - Verify webhook signatures
export async function POST(req: Request) {
  const signature = req.headers.get('x-signature')
  const body = await req.text()
  if (!verifySignature(body, signature, secret)) {
    return Response.json({ error: 'Invalid signature' }, { status: 401 })
  }
  const event = JSON.parse(body)
  await processEvent(event)
}

// ‚ùå NEVER - Store credentials in plaintext
await sql`INSERT INTO creds (token) VALUES (${accessToken})`

// ‚úÖ ALWAYS - Encrypt credentials before storage
await sql`INSERT INTO creds (token) VALUES (${encrypt(accessToken)})`
```

---

## Tax Compliance Patterns

**CRITICAL**: Tax data requires the highest level of security. TINs are encrypted at rest, access is logged, and all operations must maintain audit trails.

### TIN Encryption Pattern (AES-256-GCM)

```typescript
// packages/tax/src/encryption.ts

import { createCipheriv, createDecipheriv, randomBytes } from 'crypto'

const ALGORITHM = 'aes-256-gcm'
const IV_LENGTH = 16
const AUTH_TAG_LENGTH = 16

// Key must be 64-char hex string (256 bits)
export function getEncryptionKey(): Buffer {
  const key = process.env.TAX_TIN_ENCRYPTION_KEY
  if (!key || key.length !== 64) {
    throw new Error('TAX_TIN_ENCRYPTION_KEY must be 64-char hex string')
  }
  return Buffer.from(key, 'hex')
}

// ‚úÖ CORRECT - Full encryption with auth tag
export function encryptTIN(tin: string): string {
  const key = getEncryptionKey()
  const iv = randomBytes(IV_LENGTH)
  const cipher = createCipheriv(ALGORITHM, key, iv)

  let encrypted = cipher.update(tin, 'utf8', 'base64')
  encrypted += cipher.final('base64')
  const authTag = cipher.getAuthTag()

  // Format: base64(iv + authTag + ciphertext)
  const combined = Buffer.concat([iv, authTag, Buffer.from(encrypted, 'base64')])
  return combined.toString('base64')
}

// ‚úÖ CORRECT - Decrypt with auth tag verification
export function decryptTIN(encrypted: string): string {
  const key = getEncryptionKey()
  const combined = Buffer.from(encrypted, 'base64')

  const iv = combined.subarray(0, IV_LENGTH)
  const authTag = combined.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH)
  const ciphertext = combined.subarray(IV_LENGTH + AUTH_TAG_LENGTH)

  const decipher = createDecipheriv(ALGORITHM, key, iv)
  decipher.setAuthTag(authTag)

  let decrypted = decipher.update(ciphertext, undefined, 'utf8')
  decrypted += decipher.final('utf8')
  return decrypted
}

// ‚ùå WRONG - No encryption
await sql`INSERT INTO tax_payees (tin) VALUES (${tin})`

// ‚úÖ ALWAYS - Encrypt TIN, store only last 4 plaintext
const encrypted = encryptTIN(tin)
const lastFour = tin.slice(-4)
await sql`INSERT INTO tax_payees (tin_encrypted, tin_last_four) VALUES (${encrypted}, ${lastFour})`
```

### TIN Access Logging Pattern

```typescript
// ‚úÖ CRITICAL - Log every TIN decryption with IP and user agent
export async function getEncryptedTIN(
  payeeId: string,
  payeeType: PayeeType,
  userId: string,
  reason: string,
  req?: Request
): Promise<string> {
  const payee = await getTaxPayee(payeeId, payeeType)
  if (!payee) throw new Error('No W-9 on file')

  // Decrypt TIN
  const tin = decryptTIN(payee.tinEncrypted)

  // CRITICAL: Log every access with context
  await logTaxAction({
    action: 'tin_decrypted',
    payeeId,
    payeeType,
    performedBy: userId,
    ipAddress: req?.headers.get('x-forwarded-for') || 'unknown',
    userAgent: req?.headers.get('user-agent') || 'unknown',
    notes: reason
  })

  return tin
}

// ‚ùå WRONG - Decrypt without logging
const tin = decryptTIN(payee.tinEncrypted)

// ‚úÖ ALWAYS - Use access function that logs
const tin = await getEncryptedTIN(payeeId, payeeType, userId, 'IRIS CSV generation', req)
```

### SSN/EIN Validation Pattern

```typescript
// ‚úÖ CORRECT - Reject known invalid patterns
export function isValidSSN(ssn: string): boolean {
  const digits = ssn.replace(/\D/g, '')
  if (digits.length !== 9) return false

  // IRS invalid patterns
  const area = digits.substring(0, 3)
  const group = digits.substring(3, 5)
  const serial = digits.substring(5, 9)

  if (area === '000' || area === '666' || area.startsWith('9')) return false
  if (group === '00') return false
  if (serial === '0000') return false

  // Common test/fake numbers
  const fakes = ['123456789', '111111111', '999999999', '123121234']
  if (fakes.includes(digits)) return false

  return true
}

// ‚ùå WRONG - No validation
await saveW9({ tin: userInput.tin, ... })

// ‚úÖ ALWAYS - Validate before storage
if (tinType === 'ssn' && !isValidSSN(tin)) {
  throw new Error('Invalid SSN format')
}
if (tinType === 'ein' && !isValidEIN(tin)) {
  throw new Error('Invalid EIN format')
}
await saveW9({ tin, tinType, ... })
```

### Form Status Workflow Pattern

```typescript
// Form status can only move forward, never backward
type FormStatus = 'draft' | 'pending_review' | 'approved' | 'filed' | 'corrected' | 'voided'

const VALID_TRANSITIONS: Record<FormStatus, FormStatus[]> = {
  draft: ['pending_review', 'approved', 'voided'],
  pending_review: ['approved', 'voided'],
  approved: ['filed', 'voided'],
  filed: ['corrected'],  // Cannot void filed forms - must correct
  corrected: [],         // Terminal state
  voided: []             // Terminal state
}

// ‚úÖ CORRECT - Validate transition before update
export async function updateFormStatus(
  formId: string,
  newStatus: FormStatus,
  userId: string
): Promise<void> {
  const form = await getTaxFormById(formId)
  if (!form) throw new Error('Form not found')

  const validNext = VALID_TRANSITIONS[form.status]
  if (!validNext.includes(newStatus)) {
    throw new Error(`Cannot transition from ${form.status} to ${newStatus}`)
  }

  await sql`UPDATE tax_forms SET status = ${newStatus} WHERE id = ${formId}`
  await logTaxAction({ action: `form_${newStatus}`, taxFormId: formId, performedBy: userId })
}

// ‚ùå WRONG - Direct status update without validation
await sql`UPDATE tax_forms SET status = 'voided' WHERE id = ${formId}`
```

### 1099 Threshold Tracking Pattern

```typescript
const THRESHOLD_CENTS = 60000 // $600

// ‚úÖ CORRECT - Get payees requiring 1099
export async function getPayeesRequiring1099(
  payeeType: PayeeType,
  taxYear: number
): Promise<Array<{ payeeId: string; totalCents: number }>> {
  const config = PAYMENT_SOURCES[payeeType]

  return await sql.query(`
    SELECT ${config.payeeIdColumn} as payee_id, SUM(${config.amountColumn}) as total
    FROM ${config.table}
    WHERE type = ANY($1)
      AND EXTRACT(YEAR FROM ${config.dateColumn}) = $2
    GROUP BY ${config.payeeIdColumn}
    HAVING SUM(${config.amountColumn}) >= $3
    ORDER BY total DESC
  `, [config.taxableTypes, taxYear, THRESHOLD_CENTS])
}

// ‚úÖ CORRECT - Get payees approaching threshold (50-99%)
export async function getPayeesApproachingThreshold(
  payeeType: PayeeType,
  taxYear: number
): Promise<Array<{ payeeId: string; percentOfThreshold: number }>> {
  const minCents = THRESHOLD_CENTS * 0.5
  // ... query BETWEEN minCents AND THRESHOLD_CENTS - 1
}
```

### W-9 Reminder Automation Pattern

```typescript
// ‚úÖ CORRECT - 4-level escalation cadence
export const W9_REMINDER_SCHEDULE = {
  initial: 0,         // Day 0: Initial request when payments start
  reminder_1: 7,      // Day 7: First reminder
  reminder_2: 14,     // Day 14: Second reminder (urgent)
  final_notice: 21    // Day 21: Final notice (escalation)
}

// Scheduled task runs daily
export const w9ComplianceReminders = schedules.task({
  id: 'w9-compliance-reminders',
  cron: '0 9 * * *', // Daily at 9 AM
  run: async () => {
    const payeesNeedingW9 = await getPayeesMissingW9(getCurrentYear())

    for (const { payeeId, payeeType } of payeesNeedingW9) {
      const tracking = await getW9Tracking(payeeId, payeeType)

      // Determine which reminder to send based on tracking history
      const nextReminder = determineNextReminder(tracking)
      if (nextReminder) {
        await sendW9Request(payeeId, payeeType, nextReminder.type)
        await updateW9Tracking(payeeId, payeeType, nextReminder.field, new Date())
      }
    }
  }
})
```

### Corrections Pattern

```typescript
// Type 1: Amount correction (same recipient, different amounts)
// Type 2: Info correction (voids original, creates new with corrected info)

// ‚úÖ CORRECT - Type 1 correction
export async function createAmountCorrection(
  originalFormId: string,
  newAmounts: Record<string, number>,
  reason: string,
  userId: string
): Promise<TaxForm> {
  const original = await getTaxFormById(originalFormId)
  if (original.status !== 'filed') {
    throw new Error('Can only correct filed forms')
  }

  const correction: TaxForm = {
    ...original,
    id: generateCorrectionId('type1'),
    boxAmounts: newAmounts,
    status: 'draft',
    originalFormId,
    correctionType: 'type1'
  }

  await insertTaxForm(correction)
  await logTaxAction({ action: 'form_corrected', taxFormId: correction.id, ... })
  return correction
}

// ‚ùå WRONG - Void a filed form
await sql`UPDATE tax_forms SET status = 'voided' WHERE id = ${filedFormId}`
// This breaks IRS records! Must create correction instead
```

### Tax Compliance Anti-Patterns

```typescript
// ‚ùå NEVER - Store TIN unencrypted
await sql`INSERT INTO tax_payees (tin) VALUES ($1)`, [tin]

// ‚úÖ ALWAYS - Encrypt before storage
const encrypted = encryptTIN(tin)
await sql`INSERT INTO tax_payees (tin_encrypted, tin_last_four) VALUES ($1, $2)`,
  [encrypted, tin.slice(-4)]

// ‚ùå NEVER - Decrypt without logging
const tin = decryptTIN(payee.tinEncrypted)

// ‚úÖ ALWAYS - Use logged access function
const tin = await getEncryptedTIN(payeeId, payeeType, userId, reason, req)

// ‚ùå NEVER - Skip SSN/EIN validation
await saveW9({ tin: userInput, ... })

// ‚úÖ ALWAYS - Validate before storage
if (!isValidSSN(tin) && !isValidEIN(tin)) throw new Error('Invalid TIN format')

// ‚ùå NEVER - Allow backward status transitions
await sql`UPDATE tax_forms SET status = 'draft' WHERE id = ${filedFormId}`

// ‚úÖ ALWAYS - Validate transitions via state machine
await updateFormStatus(formId, 'approved', userId)

// ‚ùå NEVER - Void a filed form
await voidForm(filedFormId) // Breaks IRS records!

// ‚úÖ ALWAYS - Create correction for filed forms
await createAmountCorrection(filedFormId, correctedAmounts, reason, userId)

// ‚ùå NEVER - Generate 1099 without W-9
await generate1099(payeeId, payeeType, taxYear)

// ‚úÖ ALWAYS - Check W-9 exists first
const taxPayee = await getTaxPayee(payeeId, payeeType)
if (!taxPayee?.w9CertifiedAt) {
  throw new Error('W-9 must be on file before generating 1099')
}
```

---

## Vendor Management Patterns

Vendors are **business entities** with specific B2B requirements. They differ from creators and contractors in payment models and tax treatment.

### Business Entity Types

```typescript
// packages/vendor-portal/src/types/vendor.ts

type BusinessType =
  | 'sole_prop'    // SSN allowed
  | 'llc'          // SSN or EIN (single-member)
  | 'llc_s'        // EIN required (S-Corp election)
  | 'llc_c'        // EIN required (C-Corp election)
  | 's_corp'       // EIN required
  | 'c_corp'       // EIN required
  | 'partnership'  // EIN required
  | 'trust'        // EIN required
  | 'nonprofit'    // EIN required
  | 'other'        // EIN required

type PaymentTerms = 'due_on_receipt' | 'net_15' | 'net_30' | 'net_45' | 'net_60'

function requiresEIN(businessType: BusinessType): boolean {
  // Only sole props and single-member LLCs can use SSN
  return !['sole_prop', 'llc'].includes(businessType)
}
```

### Invoice Workflow Pattern

```typescript
// packages/vendor-portal/src/lib/invoices.ts

type InvoiceStatus = 'submitted' | 'pending_review' | 'approved' | 'rejected' | 'paid'

// ‚úÖ CORRECT - Calculate due date from vendor's payment terms
export function calculateDueDate(submittedAt: Date, paymentTerms: PaymentTerms): Date {
  const daysMap: Record<PaymentTerms, number> = {
    due_on_receipt: 0,
    net_15: 15,
    net_30: 30,
    net_45: 45,
    net_60: 60
  }

  const dueDate = new Date(submittedAt)
  dueDate.setDate(dueDate.getDate() + daysMap[paymentTerms])
  return dueDate
}

// ‚úÖ CORRECT - Submit invoice with tenant context
export async function submitInvoice(
  tenantId: string,
  vendorId: string,
  invoice: InvoiceSubmission
): Promise<VendorInvoice> {
  // Get vendor's payment terms
  const vendor = await withTenant(tenantId, async () => {
    return sql`SELECT payment_terms FROM vendors WHERE id = ${vendorId} AND tenant_id = ${tenantId}`
  })

  if (!vendor.rows[0]) {
    throw new Error('Vendor not found')
  }

  const dueDate = calculateDueDate(new Date(), vendor.rows[0].payment_terms)

  return await withTenant(tenantId, async () => {
    return sql`
      INSERT INTO vendor_invoices (
        tenant_id, vendor_id, invoice_number, description,
        amount_cents, service_date, due_date, status
      ) VALUES (
        ${tenantId}, ${vendorId}, ${invoice.invoiceNumber}, ${invoice.description},
        ${invoice.amountCents}, ${invoice.serviceDate}, ${dueDate}, 'submitted'
      )
      RETURNING *
    `
  })
}
```

### Invoice Approval Pattern

```typescript
// packages/admin-core/src/lib/vendor-invoices.ts

// ‚úÖ CORRECT - Approve invoice and create payment
export async function approveInvoice(
  tenantId: string,
  invoiceId: string,
  adminUserId: string,
  notes?: string
): Promise<void> {
  await withTenant(tenantId, async () => {
    // Update invoice status
    await sql`
      UPDATE vendor_invoices
      SET status = 'approved',
          reviewed_by = ${adminUserId},
          reviewed_at = now(),
          review_notes = ${notes || null},
          status_changed_at = now()
      WHERE id = ${invoiceId} AND tenant_id = ${tenantId}
    `

    // Get invoice and vendor for payment creation
    const invoice = await sql`SELECT * FROM vendor_invoices WHERE id = ${invoiceId}`
    const vendor = await sql`SELECT * FROM vendors WHERE id = ${invoice.rows[0].vendor_id}`

    // Get payee record
    const payee = await sql`
      SELECT id FROM payees
      WHERE payee_type = 'vendor' AND reference_id = ${vendor.rows[0].id}
    `

    if (payee.rows[0]) {
      // Create pending payment request
      await createPaymentRequest({
        payeeId: payee.rows[0].id,
        amountCents: invoice.rows[0].amount_cents,
        referenceType: 'vendor_invoice',
        referenceId: invoiceId,
        notes: `Invoice ${invoice.rows[0].invoice_number || invoiceId}`
      })
    }
  })

  // Notify vendor of approval
  await sendVendorNotification(tenantId, invoiceId, 'invoice_approved')
}

// ‚úÖ CORRECT - Reject invoice with reason
export async function rejectInvoice(
  tenantId: string,
  invoiceId: string,
  adminUserId: string,
  reason: string
): Promise<void> {
  await withTenant(tenantId, async () => {
    await sql`
      UPDATE vendor_invoices
      SET status = 'rejected',
          reviewed_by = ${adminUserId},
          reviewed_at = now(),
          rejection_reason = ${reason},
          status_changed_at = now()
      WHERE id = ${invoiceId} AND tenant_id = ${tenantId}
    `
  })

  // Notify vendor with rejection reason
  await sendVendorNotification(tenantId, invoiceId, 'invoice_rejected', { reason })
}
```

### Overdue Invoice Detection

```typescript
// packages/admin-core/src/lib/vendor-invoices.ts

// ‚úÖ CORRECT - Get overdue invoices for admin queue
export async function getOverdueInvoices(tenantId: string): Promise<OverdueInvoice[]> {
  return await withTenant(tenantId, async () => {
    const result = await sql`
      SELECT
        vi.*,
        v.name as vendor_name,
        v.company as vendor_company,
        CURRENT_DATE - vi.due_date as days_overdue
      FROM vendor_invoices vi
      JOIN vendors v ON vi.vendor_id = v.id
      WHERE vi.tenant_id = ${tenantId}
        AND vi.status = 'approved'
        AND vi.due_date < CURRENT_DATE
      ORDER BY vi.due_date ASC
    `
    return result.rows
  })
}

// Background job: Check for newly overdue invoices
export async function checkOverdueInvoices(tenantId: string): Promise<void> {
  const newlyOverdue = await withTenant(tenantId, async () => {
    return sql`
      SELECT id FROM vendor_invoices
      WHERE tenant_id = ${tenantId}
        AND status = 'approved'
        AND due_date = CURRENT_DATE - 1  -- Became overdue yesterday
    `
  })

  for (const invoice of newlyOverdue.rows) {
    await sendAdminNotification(tenantId, 'invoice_overdue', {
      invoiceId: invoice.id
    })
  }
}
```

### Vendor Anti-Patterns

```typescript
// ‚ùå NEVER - Allow SSN for business entities requiring EIN
await saveVendorW9({
  businessType: 's_corp',
  tinType: 'ssn',  // Wrong! S-Corp requires EIN
  tin: '123-45-6789'
})

// ‚úÖ ALWAYS - Validate TIN type matches business entity
if (requiresEIN(businessType) && tinType === 'ssn') {
  throw new Error('This business type requires an EIN, not an SSN')
}

// ‚ùå NEVER - Use 1099-NEC for vendors
await generate1099(vendorPayeeId, 'vendor', taxYear, '1099-NEC')

// ‚úÖ ALWAYS - Use 1099-MISC for vendors
await generate1099(vendorPayeeId, 'vendor', taxYear, '1099-MISC')

// ‚ùå NEVER - Let vendors set their own payment terms
await updateVendor({ paymentTerms: req.body.paymentTerms })

// ‚úÖ ALWAYS - Payment terms set by admin only
// Vendors can VIEW their terms but not edit them
const vendorSettings = await getVendorSettings(vendorId)
// Read-only: vendorSettings.paymentTerms

// ‚ùå NEVER - Delete invoices
await sql`DELETE FROM vendor_invoices WHERE id = ${invoiceId}`

// ‚úÖ ALWAYS - Reject and allow resubmission
await rejectInvoice(tenantId, invoiceId, adminId, reason)
// Vendor can then create a new corrected invoice
```

---

## E-Signature System Patterns

**CRITICAL**: The e-sign system handles legally binding documents. All coordinates, signatures, and audit trails must be precise.

### Coordinate System Pattern

```typescript
// All positions stored as percentages (0-100%) from top-left origin
interface FieldPosition {
  x: number      // 0-100%, from left edge
  y: number      // 0-100%, from top edge (CSS origin)
  width: number  // 0-100%, field width
  height: number // 0-100%, field height
  page: number   // 1-indexed page number
}

// Standard page sizes in points (72 points = 1 inch)
const PAGE_SIZES = {
  LETTER: { width: 612, height: 792 },  // 8.5" x 11"
  A4: { width: 595, height: 842 },
  LEGAL: { width: 612, height: 1008 },
}

// ‚úÖ CORRECT - Convert percentage to PDF points with Y-axis flip
export function toPdfCoordinates(
  position: FieldPosition,
  pageSize: { width: number; height: number }
): { x: number; y: number; width: number; height: number } {
  const x = (position.x / 100) * pageSize.width
  const width = (position.width / 100) * pageSize.width
  const height = (position.height / 100) * pageSize.height

  // CRITICAL: PDF Y-axis is from BOTTOM, CSS Y-axis is from TOP
  // Flip the Y coordinate: PDF_Y = pageHeight - CSS_Y - fieldHeight
  const cssY = (position.y / 100) * pageSize.height
  const y = pageSize.height - cssY - height

  return { x, y, width, height }
}

// ‚ùå WRONG - Forgot Y-axis flip
const y = (position.y / 100) * pageSize.height  // Field appears flipped!
```

### Multi-Signer Workflow Pattern

```typescript
// Signing order determines when signers can sign
// Order 1: Can sign immediately
// Order 2: Can sign after ALL Order 1 signers complete
// Same order = parallel (can sign simultaneously)

// ‚úÖ CORRECT - Get next signers ready to sign
export async function getNextSigners(documentId: string): Promise<EsignSigner[]> {
  return await withTenant(tenantId, async () => {
    const nextOrder = await sql`
      SELECT MIN(signing_order) as next_order
      FROM esign_signers
      WHERE document_id = ${documentId}
        AND role = 'signer'
        AND status NOT IN ('signed', 'declined')
    `
    if (!nextOrder.rows[0]?.next_order) return []

    return sql`
      SELECT * FROM esign_signers
      WHERE document_id = ${documentId}
        AND signing_order = ${nextOrder.rows[0].next_order}
        AND role = 'signer'
        AND status IN ('pending', 'sent', 'viewed')
    `
  })
}

// ‚ùå WRONG - Allow signing out of order
const canSign = signer.status === 'sent'  // Doesn't check order!
```

### Counter-Signature Pattern

```typescript
// Internal signers (is_internal = true) sign from admin portal, not email

// ‚úÖ CORRECT - Get pending counter-signatures for admin queue
export async function getPendingCounterSignatures(tenantId: string): Promise<CounterSignPending[]> {
  return await withTenant(tenantId, async () => {
    return sql`
      SELECT s.id, s.name, d.name as document_name,
        CASE WHEN all_external_signed THEN true ELSE false END as ready_to_sign
      FROM esign_signers s
      JOIN esign_documents d ON s.document_id = d.id
      WHERE d.tenant_id = ${tenantId}
        AND s.is_internal = true
        AND s.status NOT IN ('signed', 'declined')
    `
  })
}

// ‚ùå WRONG - Send signing email to internal signer
await sendSigningRequestEmail({ to: internalSigner.email, ... })

// ‚úÖ CORRECT - Internal signers sign from portal
if (!signer.is_internal) {
  await sendSigningRequestEmail({ to: signer.email, ... })
}
```

### PDF Field Embedding Pattern

```typescript
// ‚úÖ CORRECT - Embed fields into PDF using pdf-lib
export async function embedFieldsInPDF(
  pdfBytes: ArrayBuffer,
  fields: EsignField[],
  pageSize: PageSize = 'LETTER'
): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.load(pdfBytes)
  const pages = pdfDoc.getPages()
  const size = PAGE_SIZES[pageSize]

  for (const field of fields) {
    if (!field.value) continue
    const page = pages[field.page - 1]
    const coords = toPdfCoordinates(field.position, size)

    switch (field.type) {
      case 'signature':
        const imageBytes = await fetch(field.value).then(r => r.arrayBuffer())
        const image = await pdfDoc.embedPng(imageBytes)
        page.drawImage(image, { x: coords.x, y: coords.y, width: coords.width, height: coords.height })
        break
      case 'text':
        page.drawText(field.value, { x: coords.x, y: coords.y + coords.height - 12, size: 12 })
        break
      case 'checkbox':
        if (field.value === 'true') page.drawText('‚úì', { x: coords.x + 2, y: coords.y + 2, size: 14 })
        break
    }
  }

  // CRITICAL: Flatten to prevent editing
  return forceFlattenPdf(await pdfDoc.save())
}
```

### Signature Storage Pattern

```typescript
// ‚úÖ CORRECT - Store signatures in blob storage
export async function saveSignatureImage(signerId: string, base64Data: string): Promise<string> {
  const base64 = base64Data.replace(/^data:image\/\w+;base64,/, '')
  const buffer = Buffer.from(base64, 'base64')

  const blob = await put(`esign/signatures/${signerId}/${Date.now()}.png`, buffer, {
    access: 'public', contentType: 'image/png'
  })
  return blob.url
}

// ‚ùå WRONG - Store raw base64 in database
await sql`UPDATE signers SET signature = ${base64Data} WHERE id = ${signerId}`

// ‚úÖ CORRECT - Store URL reference only
const url = await saveSignatureImage(signerId, base64Data)
await sql`INSERT INTO esign_signatures (signer_id, image_url) VALUES (${signerId}, ${url})`
```

### Webhook HMAC Pattern

```typescript
import { createHmac, timingSafeEqual } from 'crypto'

// ‚úÖ CORRECT - Generate and verify HMAC signatures
export function generateWebhookSignature(payload: string, secret: string): string {
  return createHmac('sha256', secret).update(payload).digest('hex')
}

export function verifyWebhookSignature(payload: string, signature: string, secret: string): boolean {
  const expected = generateWebhookSignature(payload, secret)
  return timingSafeEqual(Buffer.from(signature, 'hex'), Buffer.from(expected, 'hex'))
}

// ‚ùå WRONG - No signature verification
const event = await req.json()  // Unverified!
```

### Audit Trail Pattern

```typescript
// ‚úÖ CORRECT - Append-only audit log
export async function logAuditEvent(event: {
  documentId: string
  action: 'created' | 'sent' | 'viewed' | 'signed' | 'declined' | 'voided'
  actorType: 'signer' | 'admin' | 'system'
  ipAddress?: string
}): Promise<void> {
  await sql`
    INSERT INTO esign_audit_log (document_id, action, actor_type, ip_address)
    VALUES (${event.documentId}, ${event.action}, ${event.actorType}, ${event.ipAddress})
  `
  // NOTE: No UPDATE or DELETE on audit log - append only
}

// ‚ùå WRONG - Allow editing audit log
await sql`UPDATE esign_audit_log SET action = 'corrected' WHERE id = ${eventId}`
```

### E-Sign Anti-Patterns

```typescript
// ‚ùå NEVER - Forget Y-axis flip for PDF coordinates
const y = (position.y / 100) * pageHeight  // Wrong! PDF Y is from bottom

// ‚úÖ ALWAYS - Flip Y axis for PDF
const y = pageHeight - cssY - fieldHeight

// ‚ùå NEVER - Allow signing out of order
if (signer.status === 'sent') { await completeSigning(signerId) }

// ‚úÖ ALWAYS - Verify it's this signer's turn
const nextSigners = await getNextSigners(documentId)
if (!nextSigners.some(s => s.id === signerId)) throw new Error('Not your turn')

// ‚ùå NEVER - Send webhook without signature
await fetch(webhookUrl, { body: JSON.stringify(event) })

// ‚úÖ ALWAYS - Include HMAC signature
const signature = generateWebhookSignature(body, secret)
await fetch(webhookUrl, { headers: { 'X-Esign-Signature': signature }, body })

// ‚ùå NEVER - Modify audit log entries
await sql`UPDATE esign_audit_log SET ... WHERE id = ${id}`

// ‚úÖ ALWAYS - Audit log is append-only
await sql`INSERT INTO esign_audit_log (...) VALUES (...)`
```

---

## Support & Help Desk Patterns

### Ticket Isolation Pattern

```typescript
// ‚úÖ CORRECT - Always scope tickets to tenant
export async function getTickets(
  tenantId: string,
  filters: TicketFilters
): Promise<PaginatedTickets> {
  return await withTenant(tenantId, async () => {
    return sql`
      SELECT t.*, a.name as agent_name
      FROM support_tickets t
      LEFT JOIN support_agents a ON t.assigned_to = a.id
      WHERE (${filters.status} IS NULL OR t.status = ${filters.status})
        AND (${filters.priority} IS NULL OR t.priority = ${filters.priority})
      ORDER BY
        CASE t.priority
          WHEN 'urgent' THEN 1
          WHEN 'high' THEN 2
          WHEN 'normal' THEN 3
          WHEN 'low' THEN 4
        END,
        t.created_at ASC
      LIMIT ${filters.limit} OFFSET ${filters.offset}
    `
  })
}
```

### SLA Calculation Pattern

```typescript
// SLA deadlines by priority
const SLA_DEADLINES = {
  urgent: { firstResponse: 1, resolution: 4 },      // hours
  high: { firstResponse: 4, resolution: 24 },
  normal: { firstResponse: 24, resolution: 72 },
  low: { firstResponse: 72, resolution: 168 },
}

export function calculateSLADeadline(
  priority: TicketPriority,
  createdAt: Date
): Date {
  const hours = SLA_DEADLINES[priority].resolution
  return new Date(createdAt.getTime() + hours * 60 * 60 * 1000)
}

// Check for SLA breaches (background job)
export async function checkSLABreaches(tenantId: string): Promise<void> {
  await withTenant(tenantId, async () => {
    await sql`
      UPDATE support_tickets
      SET sla_breached = true
      WHERE sla_deadline < NOW()
        AND sla_breached = false
        AND status NOT IN ('resolved', 'closed')
    `
  })
}
```

### Auto-Assignment Pattern

```typescript
export async function autoAssignTicket(
  tenantId: string,
  ticketId: string
): Promise<string | null> {
  return await withTenant(tenantId, async () => {
    // Find available agent with lowest load
    const agent = await sql`
      SELECT id FROM support_agents
      WHERE is_active = true
        AND is_online = true
        AND current_ticket_count < max_tickets
      ORDER BY current_ticket_count ASC
      LIMIT 1
      FOR UPDATE SKIP LOCKED
    `

    if (!agent.rows[0]) return null

    const agentId = agent.rows[0].id

    // Assign ticket and increment counter atomically
    await sql`
      UPDATE support_tickets SET assigned_to = ${agentId} WHERE id = ${ticketId}
    `
    await sql`
      UPDATE support_agents
      SET current_ticket_count = current_ticket_count + 1
      WHERE id = ${agentId}
    `

    return agentId
  })
}
```

### Sentiment Analysis Pattern

```typescript
// Analyze ticket content for negative sentiment
export async function analyzeTicketSentiment(
  ticketId: string,
  content: string
): Promise<SentimentResult> {
  try {
    // Use Claude API for sentiment analysis
    const response = await anthropic.messages.create({
      model: 'claude-3-haiku-20240307',
      max_tokens: 100,
      messages: [{
        role: 'user',
        content: `Analyze the sentiment of this support message. Return JSON: {"score": -1 to 1, "confidence": 0 to 1}\n\n${content}`
      }]
    })

    const result = JSON.parse(response.content[0].text)

    // Auto-escalate if very negative
    if (result.score <= -0.7 && result.confidence >= 0.8) {
      await escalateTicketPriority(ticketId, 'high', 'Negative sentiment detected')
    }

    return result
  } catch (error) {
    // Fallback to keyword-based analysis
    return keywordSentimentAnalysis(content)
  }
}
```

### Knowledge Base Search Pattern

```typescript
// Full-text search with ranking
export async function searchArticles(
  tenantId: string,
  query: string
): Promise<SearchResult[]> {
  return await withTenant(tenantId, async () => {
    return sql`
      SELECT id, slug, title, excerpt,
        ts_rank(
          to_tsvector('english', title || ' ' || content || ' ' || array_to_string(tags, ' ')),
          plainto_tsquery('english', ${query})
        ) AS rank
      FROM kb_articles
      WHERE is_published = true
        AND to_tsvector('english', title || ' ' || content || ' ' || array_to_string(tags, ' '))
            @@ plainto_tsquery('english', ${query})
      ORDER BY rank DESC
      LIMIT 10
    `
  })
}
```

### Privacy Request Deadline Pattern

```typescript
// Calculate compliance deadline based on regulation
export function calculatePrivacyDeadline(
  requestType: PrivacyRequestType,
  regulation: 'gdpr' | 'ccpa' = 'gdpr'
): Date {
  const days = regulation === 'gdpr' ? 30 : 45  // CCPA allows 45 days
  return new Date(Date.now() + days * 24 * 60 * 60 * 1000)
}

// Get overdue requests (background job alert trigger)
export async function getOverdueRequests(tenantId: string): Promise<PrivacyRequest[]> {
  return await withTenant(tenantId, async () => {
    return sql`
      SELECT * FROM privacy_requests
      WHERE deadline_at < NOW()
        AND status NOT IN ('completed', 'rejected')
      ORDER BY deadline_at ASC
    `
  })
}
```

### Support Anti-Patterns

```typescript
// ‚ùå NEVER - Internal comments visible to customers
const comments = await sql`SELECT * FROM ticket_comments WHERE ticket_id = ${ticketId}`
return comments.filter(c => !c.is_internal) // Filter at app level

// ‚úÖ ALWAYS - Filter at database level
const comments = await sql`
  SELECT * FROM ticket_comments
  WHERE ticket_id = ${ticketId} AND is_internal = false
`

// ‚ùå NEVER - Query tickets without tenant context
const tickets = await sql`SELECT * FROM support_tickets WHERE status = 'open'`

// ‚úÖ ALWAYS - Use withTenant wrapper
const tickets = await withTenant(tenantId, () =>
  sql`SELECT * FROM support_tickets WHERE status = 'open'`
)

// ‚ùå NEVER - Skip SLA calculation on ticket create
await sql`INSERT INTO support_tickets (subject, ...) VALUES (...)`

// ‚úÖ ALWAYS - Calculate SLA deadline at creation
const slaDeadline = calculateSLADeadline(priority, new Date())
await sql`INSERT INTO support_tickets (subject, sla_deadline, ...) VALUES (...)`

// ‚ùå NEVER - Process privacy request without deadline
await createPrivacyRequest({ email, requestType })

// ‚úÖ ALWAYS - Set compliance deadline
await createPrivacyRequest({
  email,
  requestType,
  deadlineAt: calculatePrivacyDeadline(requestType, 'gdpr')
})
```

---

## Scheduling & Booking Patterns

### Timezone Handling (CRITICAL)

**All times stored as UTC, displayed in user's timezone.**

```typescript
// ‚úÖ CORRECT - Store as UTC, track display timezone
const booking = await createBooking({
  startTime: new Date(selectedSlot).toISOString(), // UTC
  endTime: new Date(endTime).toISOString(),        // UTC
  timezone: inviteeTimezone,                        // For display only
})

// ‚úÖ CORRECT - Display in user's timezone
import { formatInTimeZone } from 'date-fns-tz'
const displayTime = formatInTimeZone(booking.startTime, booking.timezone, 'PPpp')

// ‚ùå WRONG - Storing local time
const startTime = new Date(`${date} ${time}`).toISOString() // Ambiguous!
```

**Slot Calculation**: Convert user's availability (their timezone) to invitee's timezone for display.

### Distributed Lock Pattern (Double-Booking Prevention)

```typescript
import { createTenantCache } from '@cgk/cache'

export async function acquireBookingLock(
  tenantId: string,
  hostUserId: string,
  startTime: string
): Promise<{ acquired: boolean; lockKey: string }> {
  const cache = createTenantCache(tenantId)
  const lockKey = `booking_lock:${hostUserId}:${startTime}`

  // SET NX (only if not exists) with 30s expiry
  const acquired = await cache.setnx(lockKey, Date.now().toString(), 30)

  return { acquired, lockKey }
}

export async function releaseBookingLock(
  tenantId: string,
  lockKey: string
): Promise<void> {
  const cache = createTenantCache(tenantId)
  await cache.del(lockKey)
}

// Usage in booking creation
export async function createBooking(tenantId: string, data: CreateBookingInput) {
  const lock = await acquireBookingLock(tenantId, data.hostUserId, data.startTime)

  if (!lock.acquired) {
    throw new Error('Time slot no longer available')
  }

  try {
    // Verify slot is still available (within lock)
    const available = await isSlotAvailable(tenantId, data.hostUserId, data.startTime)
    if (!available) {
      throw new Error('Time slot no longer available')
    }

    // Create booking
    const booking = await withTenant(tenantId, () =>
      sql`INSERT INTO scheduling_bookings (...) VALUES (...) RETURNING *`
    )

    return booking
  } finally {
    await releaseBookingLock(tenantId, lock.lockKey)
  }
}
```

### Public Booking Route Pattern (No Auth, Rate Limited)

```typescript
// /api/public/scheduling/[tenantSlug]/bookings/route.ts
import { getTenantBySlug } from '@cgk/db'
import { checkBookingRateLimit, acquireBookingLock } from '@cgk/scheduling'

export async function POST(req: Request, { params }: { params: { tenantSlug: string } }) {
  const ip = req.headers.get('x-forwarded-for') || 'unknown'

  // Rate limit check (10 bookings/minute per IP)
  const rateLimit = await checkBookingRateLimit(ip)
  if (!rateLimit.allowed) {
    return Response.json(
      { error: 'Too many requests' },
      { status: 429, headers: { 'Retry-After': rateLimit.retryAfter.toString() } }
    )
  }

  // Get tenant from slug (no auth required)
  const tenant = await getTenantBySlug(params.tenantSlug)
  if (!tenant) {
    return Response.json({ error: 'Tenant not found' }, { status: 404 })
  }

  const { hostUserId, eventTypeId, startTime, invitee } = await req.json()

  // Create booking with distributed lock
  const lock = await acquireBookingLock(tenant.id, hostUserId, startTime)
  if (!lock.acquired) {
    return Response.json({ error: 'Time slot no longer available' }, { status: 409 })
  }

  try {
    const booking = await createBooking(tenant.id, { hostUserId, eventTypeId, startTime, invitee })

    // Queue email notification (fire-and-forget)
    await queueBookingConfirmation(tenant.id, booking.id)

    return Response.json({ booking }, { status: 201 })
  } finally {
    await releaseBookingLock(tenant.id, lock.lockKey)
  }
}
```

### Google Calendar Integration Pattern

```typescript
// Token storage (encrypted at rest)
interface GoogleTokens {
  accessToken: string
  refreshToken: string
  expiresAt: number // Unix timestamp
  scope: string
}

// Encrypt before storing
export async function saveGoogleTokens(
  tenantId: string,
  userId: string,
  tokens: GoogleTokens
): Promise<void> {
  const encrypted = await encrypt(JSON.stringify(tokens))

  await withTenant(tenantId, () =>
    sql`
      UPDATE scheduling_users
      SET google_tokens_encrypted = ${encrypted}
      WHERE tenant_id = ${tenantId} AND user_id = ${userId}
    `
  )
}

// Calendar event creation with auto Meet link
export async function createCalendarEvent(
  tenantId: string,
  booking: Booking
): Promise<{ eventId: string; meetLink?: string }> {
  const tokens = await getGoogleTokens(tenantId, booking.hostUserId)
  if (!tokens) return { eventId: '' } // No calendar connected - graceful fallback

  // Refresh if expired
  if (Date.now() > tokens.expiresAt) {
    tokens = await refreshGoogleTokens(tenantId, booking.hostUserId, tokens)
  }

  const event = await calendar.events.insert({
    calendarId: 'primary',
    conferenceDataVersion: 1, // Enable Meet link generation
    requestBody: {
      summary: `${booking.eventTypeName} with ${booking.invitee.name}`,
      start: { dateTime: booking.startTime },
      end: { dateTime: booking.endTime },
      attendees: [{ email: booking.invitee.email }],
      conferenceData: {
        createRequest: { requestId: booking.id }
      }
    }
  })

  return {
    eventId: event.data.id!,
    meetLink: event.data.hangoutLink
  }
}
```

### Round-Robin Host Assignment

```typescript
export async function getNextRoundRobinHost(
  tenantId: string,
  teamEventTypeId: string,
  startTime: string,
  duration: number
): Promise<string> {
  return await withTenant(tenantId, async () => {
    // Get event type with hosts
    const eventType = await sql`
      SELECT host_user_ids FROM scheduling_team_event_types
      WHERE id = ${teamEventTypeId}
    `
    const hostIds = eventType.rows[0].host_user_ids

    // Get current index (with lock to prevent race)
    const counter = await sql`
      SELECT current_index FROM scheduling_round_robin_counters
      WHERE team_event_type_id = ${teamEventTypeId}
      FOR UPDATE
    `
    const currentIndex = counter.rows[0]?.current_index || 0

    // Find next available host
    for (let i = 0; i < hostIds.length; i++) {
      const hostIndex = (currentIndex + i) % hostIds.length
      const hostId = hostIds[hostIndex]

      if (await isHostAvailable(tenantId, hostId, startTime, duration)) {
        // Update counter for next booking
        await sql`
          UPDATE scheduling_round_robin_counters
          SET current_index = ${(hostIndex + 1) % hostIds.length}
          WHERE team_event_type_id = ${teamEventTypeId}
        `
        return hostId
      }
    }

    throw new Error('No team members available for this time slot')
  })
}
```

### Scheduling Anti-Patterns

```typescript
// ‚ùå WRONG - Storing local time
const startTime = `2025-02-15T09:00:00` // What timezone??

// ‚úÖ CORRECT - Always use UTC with timezone metadata
const startTime = new Date(selectedSlot).toISOString() // UTC
const timezone = 'America/New_York' // Stored separately

// ‚ùå WRONG - No lock for concurrent bookings
const booking = await createBooking(data) // Race condition!

// ‚úÖ CORRECT - Use distributed lock
const lock = await acquireBookingLock(tenantId, hostUserId, startTime)
try { ... } finally { await releaseBookingLock(...) }

// ‚ùå WRONG - Public booking with auth required
export async function POST(req: Request) {
  const { userId } = await auth() // Blocks public access!
  // ...
}

// ‚úÖ CORRECT - Rate limit instead of auth for public routes
const rateLimit = await checkBookingRateLimit(ip)
if (!rateLimit.allowed) return Response.json(..., { status: 429 })

// ‚ùå WRONG - Blocking on calendar integration
await createCalendarEvent(booking) // Slows down booking!

// ‚úÖ CORRECT - Fire-and-forget or queue
queueCalendarEvent(booking.id) // Non-blocking
```

---

## Creator Onboarding Patterns

### Multi-Step Form with Auto-Save Draft

**Reference**: `src/components/creator-portal/OnboardingForm.tsx`

Forms that span multiple steps must auto-save drafts to prevent data loss.

```typescript
// Auto-save draft after 1.5s of inactivity
useEffect(() => {
  if (formData.email && !initialLoading) {
    const timer = setTimeout(() => saveDraft(formData, step), 1500)
    return () => clearTimeout(timer)
  }
}, [formData, step])

// Draft API endpoints
// POST /api/creator/onboarding/draft - Save draft
// GET  /api/creator/onboarding/draft?email=... - Load draft

async function saveDraft(data: FormData, step: number) {
  await fetch('/api/creator/onboarding/draft', {
    method: 'POST',
    body: JSON.stringify({ email: data.email, draftData: data, step }),
  })
}
```

**Draft Database Pattern**:
```sql
CREATE TABLE {tenant_schema}.creator_application_drafts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL,
  email TEXT NOT NULL,
  draft_data JSONB NOT NULL,
  step INTEGER NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(tenant_id, email)  -- One draft per email per tenant
);
```

### Resume Application Pattern

Allow users to resume incomplete applications via URL.

```typescript
// URL patterns for resume
/creator/join?resume={applicationId}  // Resume by ID
/creator/join?email={email}           // Resume by email

// Resume API
GET  /api/creator/onboarding/resume?id={applicationId}
PATCH /api/creator/onboarding/resume { applicationId, step, formData }

// Check for resume on page load
useEffect(() => {
  const resumeId = searchParams.get('resume')
  const email = searchParams.get('email')

  if (resumeId) {
    loadApplicationById(resumeId)
  } else if (email) {
    loadDraftByEmail(email)
  }
}, [])
```

### Teleprompter State Persistence

**Reference**: `src/components/creator-portal/Teleprompter.tsx`

Teleprompter preferences persist to localStorage for user convenience.

```typescript
// localStorage keys for teleprompter
const STORAGE_KEYS = {
  speed: 'teleprompter_speed',       // 1-5 scroll speed
  fontSize: 'teleprompter_font_size' // 16-72px font size
}

// Load saved preferences on mount
useEffect(() => {
  const savedSpeed = localStorage.getItem(STORAGE_KEYS.speed)
  const savedFontSize = localStorage.getItem(STORAGE_KEYS.fontSize)

  if (savedSpeed) setSpeed(parseInt(savedSpeed, 10))
  if (savedFontSize) setFontSize(parseInt(savedFontSize, 10))
}, [])

// Save on change
const handleSpeedChange = (newSpeed: number) => {
  setSpeed(newSpeed)
  localStorage.setItem(STORAGE_KEYS.speed, newSpeed.toString())
}
```

### Shot Marker Parsing

Parse script text to identify shot type transitions.

```typescript
const SHOT_TYPES = {
  'B-ROLL': { color: '#3b82f6', icon: 'üé¨', label: 'B-Roll' },
  'TALKING HEAD': { color: '#22c55e', icon: 'üó£Ô∏è', label: 'Talking Head' },
  'PRODUCT SHOT': { color: '#f59e0b', icon: 'üì¶', label: 'Product Shot' },
  'CTA': { color: '#ef4444', icon: 'üéØ', label: 'Call to Action' },
}

// Parse [SHOT: TYPE] markers in script
function parseScript(script: string): ScriptSegment[] {
  const shotRegex = /\[SHOT:\s*(B-ROLL|TALKING HEAD|PRODUCT SHOT|CTA)\]/gi
  const segments: ScriptSegment[] = []
  let lastIndex = 0
  let match

  while ((match = shotRegex.exec(script)) !== null) {
    // Add text before marker
    if (match.index > lastIndex) {
      segments.push({ type: 'text', content: script.slice(lastIndex, match.index) })
    }
    // Add shot marker
    segments.push({ type: 'shot', shotType: match[1].toUpperCase() as ShotType })
    lastIndex = match.index + match[0].length
  }

  // Add remaining text
  if (lastIndex < script.length) {
    segments.push({ type: 'text', content: script.slice(lastIndex) })
  }

  return segments
}
```

### Welcome Call Scheduling Integration

**Reference**: `src/components/creator-portal/onboarding/ScheduleCallStep.tsx`

Welcome call scheduling integrates with PHASE-2SC scheduling system.

```typescript
// Three modes for welcome call configuration
interface OnboardingSettings {
  welcomeCall: {
    enabled: boolean
    mode: 'internal' | 'external' | 'disabled'
    isConfigured: boolean
    externalUrl?: string              // e.g., "https://calendly.com/brand/welcome"
    externalUrlBehavior?: 'redirect' | 'embed'
  }
}

// Internal scheduling flow
async function fetchAvailableSlots(date: string, timezone: string) {
  const res = await fetch(
    `/api/creator/scheduling/welcome-call?date=${date}&timezone=${timezone}`
  )
  return res.json() // { slots: TimeSlot[] }
}

async function bookSlot(slot: TimeSlot, timezone: string) {
  const res = await fetch('/api/creator/scheduling/welcome-call', {
    method: 'POST',
    body: JSON.stringify({
      slotStart: slot.start,
      hostId: slot.hostId,
      eventTypeId: slot.eventTypeId,
      timezone
    })
  })
  return res.json() // { bookingId }
}

// External URL handling
if (settings.welcomeCall.mode === 'external') {
  if (settings.welcomeCall.externalUrlBehavior === 'redirect') {
    window.location.href = settings.welcomeCall.externalUrl!
  } else {
    // Render iframe embed
    return <iframe src={settings.welcomeCall.externalUrl} className="w-full h-[600px]" />
  }
}
```

### Form Submission with Meta Pixel Tracking

Track Lead events for marketing attribution.

```typescript
// Submit application with Meta tracking
async function submitApplication(formData: ApplicationFormData) {
  const eventId = crypto.randomUUID() // For deduplication

  // Track Lead event client-side
  if (typeof fbq !== 'undefined') {
    fbq('track', 'Lead', {
      content_name: 'Creator Application',
      content_category: 'creator_signup'
    }, { eventID: eventId })
  }

  // Submit to API (includes eventId for server-side CAPI dedup)
  const res = await fetch('/api/creator/onboarding', {
    method: 'POST',
    body: JSON.stringify({
      ...formData,
      metaEventId: eventId,
      utmSource: searchParams.get('utm_source'),
      utmMedium: searchParams.get('utm_medium'),
      utmCampaign: searchParams.get('utm_campaign'),
      referrer: document.referrer
    })
  })

  if (res.ok) {
    router.push('/creator/join/success')
  }
}
```

### Configurable Survey Questions

Tenant admins can customize onboarding survey questions.

```typescript
interface SurveyQuestion {
  id: string
  question: string
  type: 'text' | 'textarea' | 'select' | 'multiselect'
  options?: string[]        // For select/multiselect
  placeholder?: string
  required?: boolean
}

// Fetch from tenant config
const questions = await sql`
  SELECT survey_questions FROM tenant_onboarding_settings
  WHERE tenant_id = ${tenantId}
`

// Render dynamic fields
{questions.map(q => (
  <FormField key={q.id}>
    <Label>{q.question}{q.required && ' *'}</Label>
    {q.type === 'text' && <Input ... />}
    {q.type === 'textarea' && <Textarea ... />}
    {q.type === 'select' && <Select options={q.options} ... />}
    {q.type === 'multiselect' && <MultiSelect options={q.options} ... />}
  </FormField>
))}
```

---

## AI Assistant Patterns (BRII)

**CRITICAL**: The AI Assistant system requires specific patterns for multi-tenant isolation and proper operation.

**Admin UI Specifications**: For the 14 BRI admin pages (dashboard, autonomy, integrations, team memories, etc.), see [PHASE-2AI-ADMIN.md](./phases/PHASE-2AI-ADMIN.md). That document covers page layouts, data displayed, user actions, and API endpoints.

### Agent Message Processing

```typescript
// packages/ai-agents/src/core/processor.ts

export async function processAgentMessage(params: {
  tenantId: string
  agentId: string
  message: string
  context: MessageContext
  conversationId?: string
}): Promise<AgentResponse> {
  // Always scope to tenant
  return await withTenant(params.tenantId, async () => {
    // Get agent configuration
    const agent = await getAgent(params.agentId)
    if (!agent || agent.status !== 'active') {
      throw new Error('Agent not available')
    }

    // Build RAG context from memory
    const memoryContext = await buildMemoryContext({
      agentId: params.agentId,
      query: params.message,
      maxTokens: 2000
    })

    // Build personality prompt section
    const personality = await getAgentPersonality(params.agentId)
    const personalityPrompt = buildPersonalityPromptSection(personality)

    // Check autonomy for any actions
    const autonomyCheck = await checkAutonomy(params.agentId, 'respond', params.context)

    // Process with Claude
    const response = await processWithClaude({
      message: params.message,
      systemPrompt: buildSystemPrompt(agent, personalityPrompt, memoryContext),
      tools: await getAgentTools(params.agentId),
      context: params.context
    })

    // Log the action
    await logAgentAction({
      tenantId: params.tenantId,
      agentId: params.agentId,
      actionType: 'message_response',
      description: `Responded to message`,
      toolsUsed: response.toolsUsed,
      conversationId: params.conversationId
    })

    // Trigger learning events
    agentEventBus.emit('response', {
      agentId: params.agentId,
      conversationId: params.conversationId,
      userMessage: params.message,
      agentResponse: response.text
    })

    return response
  })
}
```

### Memory Creation with Embeddings

```typescript
// ‚úÖ CORRECT - Always generate embedding and set source
export async function createMemory(params: {
  agentId: string
  memoryType: MemoryType
  title: string
  content: string
  source: 'observed' | 'told' | 'inferred' | 'corrected' | 'trained'
}): Promise<AgentMemory> {
  // Generate embedding for semantic search
  const embedding = await generateEmbedding(`${params.title}\n\n${params.content}`)

  // Set initial confidence based on source
  const sourceConfidence = {
    trained: 1.0,
    told: 0.9,
    corrected: 0.85,
    observed: 0.7,
    inferred: 0.5
  }

  return await sql`
    INSERT INTO agent_memories (
      tenant_id, agent_id, memory_type, title, content,
      embedding, confidence, source
    )
    VALUES (
      current_setting('app.tenant_id')::uuid,
      ${params.agentId},
      ${params.memoryType},
      ${params.title},
      ${params.content},
      ${JSON.stringify(embedding)}::vector,
      ${sourceConfidence[params.source]},
      ${params.source}
    )
    RETURNING *
  `
}

// ‚ùå WRONG - Creating memory without embedding
await sql`INSERT INTO agent_memories (title, content) VALUES (...)`  // No embedding = no semantic search!
```

### Autonomy Check Pattern

```typescript
// ‚úÖ CORRECT - Check autonomy before high-stakes actions
export async function processPayment(agentId: string, paymentDetails: PaymentDetails): Promise<void> {
  const autonomy = await checkAutonomy(agentId, 'process_payment', {
    amount: paymentDetails.amount
  })

  if (!autonomy.allowed) {
    if (autonomy.requiresApproval) {
      // Queue for approval
      await createApprovalRequest({
        agentId,
        actionType: 'process_payment',
        actionPayload: paymentDetails,
        reason: `Payment of $${paymentDetails.amount} to ${paymentDetails.recipient}`
      })
      return // Don't proceed, wait for approval
    }
    throw new Error(autonomy.reason)
  }

  // Proceed with payment
  await executePayment(paymentDetails)
}

// ‚ùå WRONG - Taking action without autonomy check
await executePayment(paymentDetails) // Might violate autonomy settings!
```

### Semantic Memory Search

```typescript
// ‚úÖ CORRECT - Use vector similarity for semantic search
export async function searchMemories(agentId: string, query: string): Promise<Memory[]> {
  const queryEmbedding = await generateEmbedding(query)

  return await sql`
    SELECT
      id, memory_type, title, content, confidence,
      1 - (embedding <=> ${JSON.stringify(queryEmbedding)}::vector) as similarity
    FROM agent_memories
    WHERE agent_id = ${agentId}
      AND is_active = true
      AND confidence >= 0.3
    ORDER BY
      (1 - (embedding <=> ${JSON.stringify(queryEmbedding)}::vector)) * confidence DESC
    LIMIT 10
  `
}

// ‚ùå WRONG - Using LIKE for memory search (misses semantically similar content)
await sql`SELECT * FROM agent_memories WHERE content LIKE '%${query}%'`
```

### Multi-Channel Event Routing

```typescript
// ‚úÖ CORRECT - Route events to appropriate agent with tenant context
export async function handleIncomingEvent(event: IncomingEvent): Promise<void> {
  // Resolve tenant from event source
  const tenantId = await resolveTenantFromEvent(event)
  if (!tenantId) {
    console.log('Unknown tenant for event:', event.source)
    return
  }

  // Route to appropriate agent within tenant
  const { agentId, reason } = await routeToAgent({
    tenantId,
    message: event.content,
    channel: event.channel,
    context: event.context
  })

  // Process within tenant scope
  await withTenant(tenantId, async () => {
    await processAgentMessage({
      tenantId,
      agentId,
      message: event.content,
      context: { channel: event.channel, ...event.context }
    })
  })
}
```

### Voice Call Processing

```typescript
// ‚úÖ CORRECT - Handle real-time voice with streaming
export async function handleVoiceLLM(
  agentId: string,
  socket: WebSocket,
  callId: string
): Promise<void> {
  socket.onmessage = async (event) => {
    const message = JSON.parse(event.data)

    if (message.type === 'user_transcript') {
      // Get agent and build context
      const context = await buildCallContext(agentId, callId)

      // Process with low latency
      const response = await processAgentMessage({
        tenantId: context.tenantId,
        agentId,
        message: message.transcript,
        context: { channel: 'voice', callId }
      })

      // Stream response back
      socket.send(JSON.stringify({
        type: 'agent_response',
        text: response.text,
        endOfResponse: true
      }))

      // Save transcript
      await saveTranscript(callId, 'agent', response.text)
    }
  }
}
```

### AI Agent Anti-Patterns

```typescript
// ‚ùå NEVER - Cross-tenant memory access
const memories = await sql`SELECT * FROM agent_memories`  // No tenant filter!

// ‚úÖ ALWAYS - Scope to tenant
const memories = await withTenant(tenantId, () =>
  sql`SELECT * FROM agent_memories WHERE agent_id = ${agentId}`
)

// ‚ùå NEVER - Skip autonomy checks
await sendBulkMessages(recipients)  // May require approval!

// ‚úÖ ALWAYS - Check autonomy first
const autonomy = await checkAutonomy(agentId, 'send_bulk_message')
if (autonomy.requiresApproval) {
  await createApprovalRequest(...)
}

// ‚ùå NEVER - Store memory without embedding
await sql`INSERT INTO agent_memories (title, content) VALUES (...)`

// ‚úÖ ALWAYS - Generate embedding for semantic search
const embedding = await generateEmbedding(content)
await sql`INSERT INTO agent_memories (..., embedding) VALUES (..., ${embedding}::vector)`

// ‚ùå NEVER - Skip logging agent actions
await executeAction()  // No audit trail!

// ‚úÖ ALWAYS - Log all agent actions
await logAgentAction({ agentId, actionType, description })
await executeAction()
```

---

## A/B Testing Patterns

**CRITICAL**: All A/B tests must be tenant-isolated and use deterministic assignment for consistency.

### Visitor Assignment

```typescript
// packages/ab-testing/assignment.ts

import { murmurhash3 } from './hash'

// ‚úÖ CORRECT - Deterministic assignment using MurmurHash3
export function assignVariant(
  visitorId: string,
  testId: string,
  variants: Array<{ id: string; weight: number }>
): string {
  // Deterministic hash - same visitor always gets same variant
  const hash = murmurhash3(`${visitorId}:${testId}`)
  const bucket = (hash >>> 0) / 0xFFFFFFFF  // Normalize to 0-1

  let cumulative = 0
  for (const variant of variants) {
    cumulative += variant.weight / 100
    if (bucket <= cumulative) {
      return variant.id
    }
  }
  return variants[variants.length - 1].id
}

// ‚ùå NEVER - Random assignment (inconsistent experience)
const variant = variants[Math.floor(Math.random() * variants.length)]
```

### Tenant-Isolated Test Queries

```typescript
// packages/ab-testing/queries.ts

// ‚úÖ CORRECT - Always scope to tenant
export async function getActiveTests(tenantId: string) {
  return withTenant(tenantId, async () => {
    return sql`
      SELECT t.*,
             json_agg(v.*) as variants
      FROM ab_tests t
      JOIN ab_variants v ON v.test_id = t.id
      WHERE t.tenant_id = ${tenantId}
        AND t.status = 'running'
        AND t.start_date <= NOW()
        AND (t.end_date IS NULL OR t.end_date > NOW())
      GROUP BY t.id
    `
  })
}

// ‚úÖ CORRECT - Record assignment with tenant context
export async function recordAssignment(
  tenantId: string,
  testId: string,
  visitorId: string,
  variantId: string
) {
  return withTenant(tenantId, async () => {
    await sql`
      INSERT INTO ab_visitors (tenant_id, test_id, visitor_id, variant_id, assigned_at)
      VALUES (${tenantId}, ${testId}, ${visitorId}, ${variantId}, NOW())
      ON CONFLICT (tenant_id, test_id, visitor_id) DO NOTHING
    `
  })
}

// ‚ùå NEVER - Query without tenant filter
const tests = await sql`SELECT * FROM ab_tests WHERE status = 'running'`
```

### Statistical Calculations

```typescript
// packages/ab-testing/statistics.ts

// ‚úÖ CORRECT - Z-test for conversion rate significance
export function calculateZTest(
  controlConversions: number,
  controlVisitors: number,
  treatmentConversions: number,
  treatmentVisitors: number
): { zScore: number; pValue: number; significant: boolean } {
  const p1 = controlConversions / controlVisitors
  const p2 = treatmentConversions / treatmentVisitors
  const pPooled = (controlConversions + treatmentConversions) /
                  (controlVisitors + treatmentVisitors)

  const se = Math.sqrt(pPooled * (1 - pPooled) *
             (1 / controlVisitors + 1 / treatmentVisitors))

  const zScore = (p2 - p1) / se
  const pValue = 2 * (1 - normalCDF(Math.abs(zScore)))

  return {
    zScore,
    pValue,
    significant: pValue < 0.05
  }
}

// ‚úÖ CORRECT - Sample Ratio Mismatch detection
export function detectSRM(
  observedControl: number,
  observedTreatment: number,
  expectedRatio: number = 0.5
): { chiSquare: number; pValue: number; hasSRM: boolean } {
  const total = observedControl + observedTreatment
  const expectedControl = total * expectedRatio
  const expectedTreatment = total * (1 - expectedRatio)

  const chiSquare =
    Math.pow(observedControl - expectedControl, 2) / expectedControl +
    Math.pow(observedTreatment - expectedTreatment, 2) / expectedTreatment

  const pValue = 1 - chiSquareCDF(chiSquare, 1)

  return {
    chiSquare,
    pValue,
    hasSRM: pValue < 0.01  // SRM threshold more strict
  }
}

// ‚úÖ CORRECT - Bootstrap confidence interval for revenue metrics
export function bootstrapCI(
  values: number[],
  iterations: number = 10000,
  alpha: number = 0.05
): { lower: number; upper: number; mean: number } {
  const means: number[] = []

  for (let i = 0; i < iterations; i++) {
    const sample = Array.from({ length: values.length }, () =>
      values[Math.floor(Math.random() * values.length)]
    )
    means.push(sample.reduce((a, b) => a + b, 0) / sample.length)
  }

  means.sort((a, b) => a - b)
  const lowerIdx = Math.floor((alpha / 2) * iterations)
  const upperIdx = Math.floor((1 - alpha / 2) * iterations)

  return {
    lower: means[lowerIdx],
    upper: means[upperIdx],
    mean: values.reduce((a, b) => a + b, 0) / values.length
  }
}
```

### Shopify Cart Attribute Integration

```typescript
// packages/ab-testing/shopify/cart-attributes.ts

// ‚úÖ CORRECT - Inject variant into cart for checkout attribution
export async function injectCartAttributes(
  tenantId: string,
  cartId: string,
  assignments: Array<{ testId: string; variantId: string }>
) {
  const shopify = await getShopifyClient(tenantId)

  // Format: test_id:variant_id|test_id:variant_id
  const attributeValue = assignments
    .map(a => `${a.testId}:${a.variantId}`)
    .join('|')

  await shopify.cart.update(cartId, {
    attributes: [
      { key: '_ab_variants', value: attributeValue }
    ]
  })
}

// ‚úÖ CORRECT - Extract from order for attribution
export function parseOrderVariants(
  orderAttributes: Array<{ key: string; value: string }>
): Array<{ testId: string; variantId: string }> {
  const abAttr = orderAttributes.find(a => a.key === '_ab_variants')
  if (!abAttr?.value) return []

  return abAttr.value.split('|').map(pair => {
    const [testId, variantId] = pair.split(':')
    return { testId, variantId }
  })
}
```

### Multi-Armed Bandit (Thompson Sampling)

```typescript
// packages/ab-testing/mab/thompson.ts

// ‚úÖ CORRECT - Thompson Sampling for dynamic allocation
export function thompsonSampleVariant(
  variants: Array<{
    id: string
    conversions: number
    visitors: number
  }>
): string {
  let maxSample = -Infinity
  let selectedId = variants[0].id

  for (const variant of variants) {
    // Beta distribution parameters
    const alpha = variant.conversions + 1
    const beta = variant.visitors - variant.conversions + 1

    // Sample from beta distribution
    const sample = betaSample(alpha, beta)

    if (sample > maxSample) {
      maxSample = sample
      selectedId = variant.id
    }
  }

  return selectedId
}

// ‚úÖ CORRECT - Update allocation weights based on performance
export async function updateMABWeights(
  tenantId: string,
  testId: string
) {
  const stats = await getVariantStats(tenantId, testId)

  // Run simulations to estimate optimal allocation
  const simulations = 10000
  const wins: Record<string, number> = {}

  for (const v of stats) wins[v.id] = 0

  for (let i = 0; i < simulations; i++) {
    let maxSample = -Infinity
    let winner = ''

    for (const v of stats) {
      const sample = betaSample(v.conversions + 1, v.visitors - v.conversions + 1)
      if (sample > maxSample) {
        maxSample = sample
        winner = v.id
      }
    }
    wins[winner]++
  }

  // Update weights to probability of being best
  for (const v of stats) {
    const newWeight = Math.round((wins[v.id] / simulations) * 100)
    await updateVariantWeight(tenantId, testId, v.id, newWeight)
  }
}
```

### A/B Testing Anti-Patterns

```typescript
// ‚ùå NEVER - Cross-tenant test access
const tests = await sql`SELECT * FROM ab_tests WHERE status = 'running'`

// ‚úÖ ALWAYS - Scope to tenant
const tests = await withTenant(tenantId, () =>
  sql`SELECT * FROM ab_tests WHERE tenant_id = ${tenantId} AND status = 'running'`
)

// ‚ùå NEVER - Non-deterministic assignment
const variant = variants[Math.floor(Math.random() * variants.length)]

// ‚úÖ ALWAYS - Deterministic hash-based assignment
const variant = assignVariant(visitorId, testId, variants)

// ‚ùå NEVER - Skip SRM checks
if (results.pValue < 0.05) declareWinner()

// ‚úÖ ALWAYS - Check for Sample Ratio Mismatch first
const srm = detectSRM(control.visitors, treatment.visitors)
if (srm.hasSRM) {
  flagDataQualityIssue(testId, 'Sample Ratio Mismatch detected')
  return
}
if (results.pValue < 0.05) declareWinner()

// ‚ùå NEVER - Ignore minimum sample size
if (anyConversions) calculateSignificance()

// ‚úÖ ALWAYS - Require minimum sample before analysis
const MIN_VISITORS_PER_VARIANT = 100
if (Math.min(control.visitors, treatment.visitors) < MIN_VISITORS_PER_VARIANT) {
  return { status: 'collecting', message: 'Insufficient sample size' }
}

// ‚ùå NEVER - Multiple comparisons without correction
for (const variant of variants) {
  if (zTest(control, variant).pValue < 0.05) declareWinner(variant)
}

// ‚úÖ ALWAYS - Apply Holm-Bonferroni correction for multiple variants
const sortedResults = variants
  .map(v => ({ ...v, pValue: zTest(control, v).pValue }))
  .sort((a, b) => a.pValue - b.pValue)

for (let i = 0; i < sortedResults.length; i++) {
  const adjustedAlpha = 0.05 / (variants.length - i)
  sortedResults[i].significant = sortedResults[i].pValue < adjustedAlpha
}
```

---

## Video Processing Patterns

**CRITICAL**: All video operations must be tenant-isolated and use Mux for hosting.

### Direct Upload to Mux

```typescript
// packages/video/mux/uploads.ts

// ‚úÖ CORRECT - Server creates upload URL, client uploads directly to Mux
export async function createDirectUpload(tenantId: string): Promise<{
  uploadUrl: string
  uploadId: string
  videoId: string
}> {
  const video = await withTenant(tenantId, async () => {
    return sql`INSERT INTO videos (tenant_id, status) VALUES (${tenantId}, 'uploading') RETURNING *`
  })

  const upload = await mux.video.uploads.create({
    corsOrigin: '*',
    newAssetSettings: {
      playbackPolicy: ['public'],
      mp4Support: 'capped-1080p',  // Required for transcription
      normalizeAudio: true,
    },
  })

  await withTenant(tenantId, async () => {
    await sql`UPDATE videos SET mux_upload_id = ${upload.id} WHERE id = ${video.id}`
  })

  return {
    uploadUrl: upload.url,
    uploadId: upload.id,
    videoId: video.id,
  }
}

// ‚ùå NEVER - Upload through server (wastes bandwidth, doesn't scale)
const buffer = await req.arrayBuffer()
await mux.video.assets.create({ input: buffer })
```

### Mux Webhook Handling

```typescript
// apps/admin/src/app/api/v1/webhooks/mux/route.ts

// ‚úÖ CORRECT - Verify signature, handle events, update tenant-scoped video
export async function POST(req: Request) {
  const signature = req.headers.get('mux-signature')
  const body = await req.text()

  // Verify webhook signature
  if (!verifyMuxWebhook(body, signature!, process.env.MUX_WEBHOOK_SECRET)) {
    return Response.json({ error: 'Invalid signature' }, { status: 401 })
  }

  const event = JSON.parse(body)
  const assetId = event.data?.id

  // Find video by Mux asset ID (cross-tenant lookup allowed for webhooks)
  const video = await sql`SELECT * FROM videos WHERE mux_asset_id = ${assetId}`
  if (!video.rows[0]) return Response.json({ error: 'Video not found' }, { status: 404 })

  const tenantId = video.rows[0].tenant_id

  switch (event.type) {
    case 'video.asset.ready':
      await withTenant(tenantId, async () => {
        await sql`UPDATE videos SET status = 'ready', mux_playback_id = ${event.data.playback_ids[0].id} WHERE id = ${video.rows[0].id}`
      })
      break

    case 'video.asset.static_renditions.ready':
      // Trigger transcription
      await triggerTranscription(tenantId, video.rows[0].id)
      break
  }

  return Response.json({ ok: true })
}
```

### Transcription Pipeline

```typescript
// packages/video/transcription/pipeline.ts

// ‚úÖ CORRECT - Tenant-isolated transcription with job tracking
export async function startTranscription(
  tenantId: string,
  videoId: string
): Promise<string> {
  const video = await withTenant(tenantId, async () => {
    return sql`SELECT * FROM videos WHERE id = ${videoId} AND tenant_id = ${tenantId}`
  })

  if (!video.rows[0]?.mux_playback_id) {
    throw new Error('Video not ready for transcription')
  }

  // Download MP4 from Mux
  const mp4Url = `https://stream.mux.com/${video.rows[0].mux_playback_id}/capped-1080p.mp4`
  const buffer = await fetch(mp4Url).then(r => r.arrayBuffer())

  // Upload to AssemblyAI and start job
  const provider = getTranscriptionProvider()
  const uploadUrl = await provider.uploadFile(Buffer.from(buffer))
  const job = await provider.transcribe(uploadUrl, {
    speakerDiarization: true,
    autoChapters: true,
    webhookUrl: `${BASE_URL}/api/v1/webhooks/assemblyai`,
  })

  // Save job ID with tenant context
  await withTenant(tenantId, async () => {
    await sql`UPDATE videos SET transcription_job_id = ${job.id}, transcription_status = 'processing' WHERE id = ${videoId}`
  })

  return job.id
}
```

### Video Anti-Patterns

```typescript
// ‚ùå NEVER - Query videos without tenant context
const videos = await sql`SELECT * FROM videos WHERE user_id = ${userId}`

// ‚úÖ ALWAYS - Use tenant-scoped queries
const videos = await withTenant(tenantId, async () => {
  return sql`SELECT * FROM videos WHERE tenant_id = ${tenantId} AND user_id = ${userId}`
})

// ‚ùå NEVER - Upload through server
const file = await req.arrayBuffer()
await uploadToMux(file)

// ‚úÖ ALWAYS - Direct upload to Mux
const { uploadUrl } = await createDirectUpload(tenantId)
// Client POSTs directly to uploadUrl

// ‚ùå NEVER - Skip webhook verification
const event = await req.json()
handleEvent(event)

// ‚úÖ ALWAYS - Verify Mux signature
const verified = verifyMuxWebhook(body, signature, secret)
if (!verified) return Response.json({ error: 'Unauthorized' }, { status: 401 })
```

---

## Digital Asset Management (DAM) Patterns

**CRITICAL**: All DAM operations must be tenant-isolated with proper audit logging.

### Asset Upload Pattern

```typescript
// packages/dam/assets/upload.ts

// ‚úÖ CORRECT - Upload to Vercel Blob with tenant path
export async function uploadAsset(
  tenantId: string,
  userId: string,
  file: File
): Promise<Asset> {
  // Compute file hash for deduplication
  const buffer = await file.arrayBuffer()
  const hash = crypto.createHash('md5').update(Buffer.from(buffer)).digest('hex')

  // Check for duplicate
  const existing = await withTenant(tenantId, async () => {
    return sql`SELECT * FROM dam_assets WHERE tenant_id = ${tenantId} AND file_hash = ${hash}`
  })

  if (existing.rows[0]) {
    return existing.rows[0]  // Return existing asset instead of uploading duplicate
  }

  // Upload to tenant-prefixed path
  const blob = await put(`tenants/${tenantId}/assets/${hash}/${file.name}`, file, {
    access: 'public',
  })

  // Create asset record
  const asset = await withTenant(tenantId, async () => {
    return sql`
      INSERT INTO dam_assets (
        tenant_id, user_id, title, file_url, file_hash, mime_type, file_size_bytes
      ) VALUES (
        ${tenantId}, ${userId}, ${file.name}, ${blob.url}, ${hash}, ${file.type}, ${file.size}
      ) RETURNING *
    `
  })

  // Log to audit
  await logAuditEvent(tenantId, userId, 'create', 'asset', asset.rows[0].id)

  return asset.rows[0]
}
```

### Google Drive Sync Pattern

```typescript
// packages/dam/gdrive/sync.ts

// ‚úÖ CORRECT - Tenant-isolated Drive sync with encrypted tokens
export async function syncGoogleDrive(
  tenantId: string,
  connectionId: string
): Promise<SyncResult> {
  // Get connection with decrypted tokens
  const connection = await withTenant(tenantId, async () => {
    return sql`SELECT * FROM dam_gdrive_connections WHERE id = ${connectionId} AND tenant_id = ${tenantId}`
  })

  if (!connection.rows[0]) {
    throw new Error('Connection not found')
  }

  const accessToken = decryptToken(connection.rows[0].access_token_encrypted)

  // Refresh if expired
  if (new Date() > connection.rows[0].token_expires_at) {
    const newTokens = await refreshGoogleTokens(
      decryptToken(connection.rows[0].refresh_token_encrypted)
    )
    await updateConnectionTokens(tenantId, connectionId, newTokens)
  }

  // Incremental sync using page token
  const { changes, newPageToken } = await listDriveChanges(
    accessToken,
    connection.rows[0].sync_page_token
  )

  for (const change of changes) {
    if (change.removed) {
      await markFileRemoved(tenantId, connectionId, change.fileId)
    } else {
      await queueFileForImport(tenantId, connectionId, change.file)
    }
  }

  // Update page token
  await withTenant(tenantId, async () => {
    await sql`UPDATE dam_gdrive_connections SET sync_page_token = ${newPageToken}, last_sync_at = now() WHERE id = ${connectionId}`
  })

  return { processed: changes.length }
}
```

### Ad Review Workflow Pattern

```typescript
// packages/dam/ad-review/workflow.ts

// ‚úÖ CORRECT - Tenant-isolated review with consensus logic
export async function submitReviewDecision(
  tenantId: string,
  versionId: string,
  reviewerId: string,
  decision: 'approved' | 'changes_requested' | 'rejected',
  notes?: string
): Promise<void> {
  const version = await withTenant(tenantId, async () => {
    return sql`SELECT * FROM dam_ad_versions WHERE id = ${versionId} AND tenant_id = ${tenantId}`
  })

  if (!version.rows[0]) throw new Error('Version not found')

  // Record decision
  await withTenant(tenantId, async () => {
    await sql`
      INSERT INTO dam_review_decisions (tenant_id, project_id, version_id, reviewer_id, decision, notes)
      VALUES (${tenantId}, ${version.rows[0].project_id}, ${versionId}, ${reviewerId}, ${decision}, ${notes})
      ON CONFLICT (version_id, reviewer_id) DO UPDATE SET decision = ${decision}, notes = ${notes}
    `
  })

  // Check if all reviewers have approved
  const project = await withTenant(tenantId, async () => {
    return sql`SELECT * FROM dam_ad_projects WHERE id = ${version.rows[0].project_id}`
  })

  const decisions = await withTenant(tenantId, async () => {
    return sql`SELECT * FROM dam_review_decisions WHERE version_id = ${versionId}`
  })

  const allApproved = project.rows[0].assigned_reviewers.every(
    (reviewer: string) => decisions.rows.find(d => d.reviewer_id === reviewer && d.decision === 'approved')
  )

  if (allApproved) {
    await withTenant(tenantId, async () => {
      await sql`UPDATE dam_ad_projects SET status = 'approved', approved_at = now(), approved_by = 'consensus' WHERE id = ${version.rows[0].project_id}`
    })
  }
}
```

### Rights Expiry Monitoring

```typescript
// packages/dam/rights/expiry.ts

// ‚úÖ CORRECT - Scheduled job for rights expiry (Trigger.dev)
export const rightsExpiryCheckTask = task({
  id: 'dam-rights-expiry-check',
  run: async (payload: { tenantId: string }) => {
    const { tenantId } = payload

    // Assets expiring in 7 days
    const expiringSoon = await withTenant(tenantId, async () => {
      return sql`
        SELECT * FROM dam_assets
        WHERE tenant_id = ${tenantId}
          AND rights_status = 'active'
          AND rights_expires_at BETWEEN now() AND now() + INTERVAL '7 days'
      `
    })

    for (const asset of expiringSoon.rows) {
      await sendNotification({
        tenantId,
        type: 'rights_expiring',
        title: 'Rights Expiring Soon',
        body: `${asset.title} expires in ${daysUntil(asset.rights_expires_at)} days`,
        entityType: 'asset',
        entityId: asset.id,
      })
    }

    // Mark expired assets
    await withTenant(tenantId, async () => {
      await sql`
        UPDATE dam_assets
        SET rights_status = 'expired'
        WHERE tenant_id = ${tenantId}
          AND rights_status = 'active'
          AND rights_expires_at < now()
      `
    })
  }
})
```

### DAM Anti-Patterns

```typescript
// ‚ùå NEVER - Store OAuth tokens in plaintext
await sql`INSERT INTO connections (..., access_token) VALUES (..., ${token})`

// ‚úÖ ALWAYS - Encrypt tokens
const encrypted = encryptToken(token)  // AES-256-GCM
await sql`INSERT INTO connections (..., access_token_encrypted) VALUES (..., ${encrypted})`

// ‚ùå NEVER - Skip deduplication
await uploadToBlobStorage(file)  // May create duplicates

// ‚úÖ ALWAYS - Check hash first
const hash = computeHash(file)
const existing = await checkForDuplicate(tenantId, hash)
if (existing) return existing

// ‚ùå NEVER - Hard delete assets
await sql`DELETE FROM dam_assets WHERE id = ${assetId}`

// ‚úÖ ALWAYS - Soft delete to trash
await sql`UPDATE dam_assets SET deleted_at = now() WHERE id = ${assetId}`
await sql`INSERT INTO dam_trash (asset_id, asset_data, deleted_by) VALUES (...)`

// ‚ùå NEVER - Skip audit logging
await updateAsset(assetId, changes)

// ‚úÖ ALWAYS - Log all changes
await logAuditEvent(tenantId, userId, 'update', 'asset', assetId, { before, after })
await updateAsset(assetId, changes)
```

---

## OAuth & Ad Platform Integration Patterns

**CRITICAL**: Ad platform integrations (Meta, Google, TikTok) use OAuth 2.0. Klaviyo uses API key authentication. All credentials MUST be encrypted at rest.

### Supported Platforms

| Platform | Auth Type | Token Lifetime | Refresh |
|----------|-----------|----------------|---------|
| Meta Ads | OAuth 2.0 | 60 days (long-lived) | System User tokens last 60 days |
| Google Ads | OAuth 2.0 | 1 hour | Use refresh token to get new access token |
| TikTok Ads | OAuth 2.0 | 24 hours | Use refresh token (valid 365 days) |
| Klaviyo | API Key | Never expires | No refresh needed |

### OAuth State Security Pattern (CSRF Protection)

```typescript
// packages/integrations/oauth/state.ts

import { createHmac, randomBytes } from 'crypto'
import { createTenantCache } from '@cgk/cache'

// ‚úÖ CORRECT - Generate HMAC-signed state parameter
export async function generateOAuthState(
  tenantId: string,
  platform: 'meta' | 'google' | 'tiktok'
): Promise<string> {
  const cache = createTenantCache(tenantId)
  const nonce = randomBytes(16).toString('hex')
  const payload = { tenantId, platform, nonce, timestamp: Date.now() }
  const data = JSON.stringify(payload)

  // HMAC signature prevents tampering
  const signature = createHmac('sha256', process.env.OAUTH_STATE_SECRET!)
    .update(data)
    .digest('hex')

  const state = Buffer.from(`${data}:${signature}`).toString('base64url')

  // Store in Redis with 10-minute TTL (prevents replay attacks)
  await cache.set(`oauth_state:${nonce}`, data, 600)

  return state
}

// ‚úÖ CORRECT - Verify and consume state (one-time use)
export async function verifyOAuthState(
  state: string
): Promise<{ tenantId: string; platform: string } | null> {
  try {
    const decoded = Buffer.from(state, 'base64url').toString('utf8')
    const [data, signature] = decoded.split(':')
    const payload = JSON.parse(data)

    // Verify HMAC signature
    const expectedSignature = createHmac('sha256', process.env.OAUTH_STATE_SECRET!)
      .update(data)
      .digest('hex')

    if (signature !== expectedSignature) return null

    // Check timestamp (max 10 minutes)
    if (Date.now() - payload.timestamp > 600000) return null

    // Verify and delete from Redis (one-time use)
    const cache = createTenantCache(payload.tenantId)
    const stored = await cache.get(`oauth_state:${payload.nonce}`)
    if (!stored) return null

    await cache.del(`oauth_state:${payload.nonce}`)
    return { tenantId: payload.tenantId, platform: payload.platform }
  } catch {
    return null
  }
}

// ‚ùå WRONG - Unverified state parameter
const { tenantId } = JSON.parse(Buffer.from(state, 'base64').toString())
```

### Token Encryption Pattern (AES-256-GCM with PBKDF2)

```typescript
// packages/integrations/oauth/encryption.ts

import crypto from 'crypto'

// ‚úÖ CORRECT - Encrypt tokens with AES-256-GCM
export async function encryptToken(
  plaintext: string,
  encryptionKey: string
): Promise<string> {
  const salt = crypto.randomBytes(16)
  const iv = crypto.randomBytes(16)

  // Derive key using PBKDF2 (100K iterations for security)
  const key = crypto.pbkdf2Sync(encryptionKey, salt, 100000, 32, 'sha256')

  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv)
  const encrypted = Buffer.concat([cipher.update(plaintext, 'utf8'), cipher.final()])
  const authTag = cipher.getAuthTag()

  // Format: salt:iv:authTag:ciphertext (all hex-encoded)
  return [
    salt.toString('hex'),
    iv.toString('hex'),
    authTag.toString('hex'),
    encrypted.toString('hex')
  ].join(':')
}

// ‚úÖ CORRECT - Decrypt with auth tag verification
export async function decryptToken(
  ciphertext: string,
  encryptionKey: string
): Promise<string> {
  const [saltHex, ivHex, authTagHex, encryptedHex] = ciphertext.split(':')

  const salt = Buffer.from(saltHex, 'hex')
  const iv = Buffer.from(ivHex, 'hex')
  const authTag = Buffer.from(authTagHex, 'hex')
  const encrypted = Buffer.from(encryptedHex, 'hex')

  const key = crypto.pbkdf2Sync(encryptionKey, salt, 100000, 32, 'sha256')

  const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv)
  decipher.setAuthTag(authTag)

  return Buffer.concat([decipher.update(encrypted), decipher.final()]).toString('utf8')
}

// ‚ùå WRONG - Store tokens in plaintext
await sql`UPDATE connections SET access_token = ${token}`

// ‚ùå WRONG - Use weak encryption (ECB mode, no auth tag)
const cipher = crypto.createCipheriv('aes-256-ecb', key)
```

### Meta Ads OAuth Flow

```typescript
// apps/admin/src/app/api/integrations/meta/callback/route.ts

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url)
  const code = searchParams.get('code')
  const state = searchParams.get('state')

  // Verify state (CSRF protection)
  const stateData = await verifyOAuthState(state!)
  if (!stateData || stateData.platform !== 'meta') {
    return Response.redirect('/admin/integrations?error=invalid_state')
  }

  const { tenantId } = stateData

  // Exchange code for short-lived token
  const tokenResponse = await fetch(
    `https://graph.facebook.com/v19.0/oauth/access_token?` +
    new URLSearchParams({
      client_id: process.env.META_APP_ID!,
      client_secret: process.env.META_APP_SECRET!,
      redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/api/integrations/meta/callback`,
      code: code!
    })
  )

  const { access_token: shortLivedToken } = await tokenResponse.json()

  // Exchange for long-lived token (60 days)
  const longLivedResponse = await fetch(
    `https://graph.facebook.com/v19.0/oauth/access_token?` +
    new URLSearchParams({
      grant_type: 'fb_exchange_token',
      client_id: process.env.META_APP_ID!,
      client_secret: process.env.META_APP_SECRET!,
      fb_exchange_token: shortLivedToken
    })
  )

  const { access_token, expires_in } = await longLivedResponse.json()

  // Encrypt and store
  const encrypted = await encryptToken(access_token, process.env.OAUTH_ENCRYPTION_KEY!)
  await withTenant(tenantId, () =>
    sql`
      INSERT INTO meta_connections (tenant_id, access_token_encrypted, expires_at)
      VALUES (${tenantId}, ${encrypted}, NOW() + INTERVAL '${expires_in} seconds')
      ON CONFLICT (tenant_id) DO UPDATE
      SET access_token_encrypted = EXCLUDED.access_token_encrypted,
          expires_at = EXCLUDED.expires_at,
          updated_at = NOW()
    `
  )

  return Response.redirect('/admin/integrations?success=meta')
}
```

### Google Ads OAuth Flow

```typescript
// apps/admin/src/app/api/integrations/google/callback/route.ts

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url)
  const code = searchParams.get('code')
  const state = searchParams.get('state')

  const stateData = await verifyOAuthState(state!)
  if (!stateData || stateData.platform !== 'google') {
    return Response.redirect('/admin/integrations?error=invalid_state')
  }

  const { tenantId } = stateData

  // Exchange code for tokens
  const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      code: code!,
      client_id: process.env.GOOGLE_CLIENT_ID!,
      client_secret: process.env.GOOGLE_CLIENT_SECRET!,
      redirect_uri: `${process.env.NEXT_PUBLIC_APP_URL}/api/integrations/google/callback`,
      grant_type: 'authorization_code'
    })
  })

  const tokens = await tokenResponse.json()

  // CRITICAL: access_type=offline required for refresh token
  if (!tokens.refresh_token) {
    console.error('No refresh token - user may have previously authorized')
    // Must revoke and re-authorize with prompt=consent
  }

  // Encrypt both tokens
  const accessEncrypted = await encryptToken(tokens.access_token, process.env.OAUTH_ENCRYPTION_KEY!)
  const refreshEncrypted = tokens.refresh_token
    ? await encryptToken(tokens.refresh_token, process.env.OAUTH_ENCRYPTION_KEY!)
    : null

  await withTenant(tenantId, () =>
    sql`
      INSERT INTO google_connections (
        tenant_id, access_token_encrypted, refresh_token_encrypted, expires_at
      )
      VALUES (
        ${tenantId}, ${accessEncrypted}, ${refreshEncrypted},
        NOW() + INTERVAL '${tokens.expires_in} seconds'
      )
      ON CONFLICT (tenant_id) DO UPDATE
      SET access_token_encrypted = EXCLUDED.access_token_encrypted,
          refresh_token_encrypted = COALESCE(EXCLUDED.refresh_token_encrypted, google_connections.refresh_token_encrypted),
          expires_at = EXCLUDED.expires_at,
          updated_at = NOW()
    `
  )

  return Response.redirect('/admin/integrations?success=google')
}

// Token refresh pattern
export async function refreshGoogleToken(tenantId: string): Promise<string> {
  const connection = await getGoogleConnection(tenantId)
  const refreshToken = await decryptToken(
    connection.refresh_token_encrypted,
    process.env.OAUTH_ENCRYPTION_KEY!
  )

  const response = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: process.env.GOOGLE_CLIENT_ID!,
      client_secret: process.env.GOOGLE_CLIENT_SECRET!,
      refresh_token: refreshToken,
      grant_type: 'refresh_token'
    })
  })

  const tokens = await response.json()

  // Handle invalid_grant (user revoked access)
  if (tokens.error === 'invalid_grant') {
    await markConnectionInvalid(tenantId, 'google', 'Refresh token revoked')
    throw new Error('Google connection requires reauthorization')
  }

  // Update stored access token
  const encrypted = await encryptToken(tokens.access_token, process.env.OAUTH_ENCRYPTION_KEY!)
  await updateGoogleAccessToken(tenantId, encrypted, tokens.expires_in)

  return tokens.access_token
}
```

### TikTok Ads OAuth Flow

```typescript
// apps/admin/src/app/api/integrations/tiktok/callback/route.ts

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url)
  const auth_code = searchParams.get('auth_code')
  const state = searchParams.get('state')

  const stateData = await verifyOAuthState(state!)
  if (!stateData || stateData.platform !== 'tiktok') {
    return Response.redirect('/admin/integrations?error=invalid_state')
  }

  const { tenantId } = stateData

  // TikTok uses different parameter names
  const response = await fetch('https://business-api.tiktok.com/open_api/v1.3/oauth2/access_token/', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      app_id: process.env.TIKTOK_APP_ID,
      secret: process.env.TIKTOK_APP_SECRET,
      auth_code,
      grant_type: 'authorization_code'
    })
  })

  const data = await response.json()

  // TikTok uses code=0 for success (not HTTP status)
  if (data.code !== 0) {
    console.error('TikTok OAuth error:', data.message)
    return Response.redirect('/admin/integrations?error=tiktok_auth_failed')
  }

  const { access_token, refresh_token, access_token_expires_in, refresh_token_expires_in } = data.data

  // Encrypt tokens
  const accessEncrypted = await encryptToken(access_token, process.env.OAUTH_ENCRYPTION_KEY!)
  const refreshEncrypted = await encryptToken(refresh_token, process.env.OAUTH_ENCRYPTION_KEY!)

  await withTenant(tenantId, () =>
    sql`
      INSERT INTO tiktok_connections (
        tenant_id, access_token_encrypted, refresh_token_encrypted,
        access_expires_at, refresh_expires_at
      )
      VALUES (
        ${tenantId}, ${accessEncrypted}, ${refreshEncrypted},
        NOW() + INTERVAL '${access_token_expires_in} seconds',
        NOW() + INTERVAL '${refresh_token_expires_in} seconds'
      )
      ON CONFLICT (tenant_id) DO UPDATE SET
        access_token_encrypted = EXCLUDED.access_token_encrypted,
        refresh_token_encrypted = EXCLUDED.refresh_token_encrypted,
        access_expires_at = EXCLUDED.access_expires_at,
        refresh_expires_at = EXCLUDED.refresh_expires_at,
        updated_at = NOW()
    `
  )

  return Response.redirect('/admin/integrations?success=tiktok')
}
```

### Klaviyo API Key Pattern (Non-OAuth)

```typescript
// apps/admin/src/app/api/integrations/klaviyo/connect/route.ts

export async function POST(req: Request) {
  const { tenantId } = await getTenantContext(req)
  const { apiKey } = await req.json()

  // Validate API key format (must start with pk_)
  if (!apiKey.startsWith('pk_')) {
    return Response.json({ error: 'Invalid Klaviyo API key format' }, { status: 400 })
  }

  // Test the API key by making a simple request
  const testResponse = await fetch('https://a.klaviyo.com/api/accounts/', {
    headers: {
      'Authorization': `Klaviyo-API-Key ${apiKey}`,
      'revision': '2024-02-15'
    }
  })

  if (!testResponse.ok) {
    return Response.json({ error: 'Invalid API key' }, { status: 400 })
  }

  // Encrypt and store (same encryption as OAuth tokens)
  const encrypted = await encryptToken(apiKey, process.env.OAUTH_ENCRYPTION_KEY!)

  await withTenant(tenantId, () =>
    sql`
      INSERT INTO klaviyo_connections (tenant_id, api_key_encrypted, status)
      VALUES (${tenantId}, ${encrypted}, 'connected')
      ON CONFLICT (tenant_id) DO UPDATE
      SET api_key_encrypted = EXCLUDED.api_key_encrypted,
          status = 'connected',
          updated_at = NOW()
    `
  )

  return Response.json({ success: true })
}
```

### Scheduled Token Refresh Job

```typescript
// packages/jobs/src/integrations/refresh-oauth-tokens.ts

export const refreshOAuthTokens = schedules.task({
  id: 'refresh-oauth-tokens',
  cron: '0 */4 * * *', // Every 4 hours
  run: async () => {
    // Google: Refresh tokens expiring in next 30 minutes
    const googleConnections = await sql`
      SELECT tenant_id FROM google_connections
      WHERE status = 'connected'
        AND expires_at < NOW() + INTERVAL '30 minutes'
    `

    for (const conn of googleConnections.rows) {
      try {
        await refreshGoogleToken(conn.tenant_id)
      } catch (error) {
        console.error(`Failed to refresh Google token for tenant ${conn.tenant_id}:`, error)
        // Mark as needs_reauth if refresh fails
        if (error.message.includes('invalid_grant')) {
          await markConnectionInvalid(conn.tenant_id, 'google', error.message)
        }
      }
    }

    // TikTok: Refresh tokens expiring in next 2 hours (24hr lifetime)
    const tiktokConnections = await sql`
      SELECT tenant_id FROM tiktok_connections
      WHERE status = 'connected'
        AND access_expires_at < NOW() + INTERVAL '2 hours'
    `

    for (const conn of tiktokConnections.rows) {
      try {
        await refreshTikTokToken(conn.tenant_id)
      } catch (error) {
        console.error(`Failed to refresh TikTok token for tenant ${conn.tenant_id}:`, error)
      }
    }

    // Meta: Alert for tokens expiring in next 7 days (60-day lifetime)
    const metaConnections = await sql`
      SELECT tenant_id FROM meta_connections
      WHERE status = 'connected'
        AND expires_at < NOW() + INTERVAL '7 days'
    `

    for (const conn of metaConnections.rows) {
      await sendAdminNotification(conn.tenant_id, 'meta_token_expiring', {
        expiresAt: conn.expires_at
      })
    }
  }
})
```

### Multi-Tenant Credential Isolation Pattern

```typescript
// ‚úÖ CORRECT - Get platform connection with tenant isolation
export async function getMetaConnection(tenantId: string): Promise<MetaConnection | null> {
  return await withTenant(tenantId, async () => {
    const result = await sql`
      SELECT * FROM meta_connections
      WHERE tenant_id = ${tenantId}
        AND status = 'connected'
    `
    return result.rows[0] || null
  })
}

// ‚úÖ CORRECT - Get decrypted token for API calls
export async function getMetaAccessToken(tenantId: string): Promise<string> {
  const connection = await getMetaConnection(tenantId)
  if (!connection) {
    throw new Error('Meta Ads not connected for this tenant')
  }

  // Check expiration
  if (new Date(connection.expires_at) < new Date()) {
    throw new Error('Meta token expired - requires reauthorization')
  }

  return await decryptToken(
    connection.access_token_encrypted,
    process.env.OAUTH_ENCRYPTION_KEY!
  )
}

// ‚ùå WRONG - Query without tenant context
const connection = await sql`SELECT * FROM meta_connections LIMIT 1`

// ‚ùå WRONG - Store encryption key in database
await sql`INSERT INTO connections (encryption_key, ...) VALUES (...)`
```

### OAuth Anti-Patterns

```typescript
// ‚ùå NEVER - Skip state verification
export async function callback(req: Request) {
  const code = searchParams.get('code')
  await exchangeToken(code) // No CSRF protection!
}

// ‚úÖ ALWAYS - Verify HMAC-signed state
const stateData = await verifyOAuthState(state)
if (!stateData) return Response.redirect('/error?msg=invalid_state')

// ‚ùå NEVER - Store tokens in plaintext
await sql`UPDATE connections SET access_token = ${token}`

// ‚úÖ ALWAYS - Encrypt with AES-256-GCM
const encrypted = await encryptToken(token, process.env.OAUTH_ENCRYPTION_KEY!)
await sql`UPDATE connections SET access_token_encrypted = ${encrypted}`

// ‚ùå NEVER - Share tokens across tenants
const token = await getGlobalMetaToken()

// ‚úÖ ALWAYS - Tokens are per-tenant
const token = await getMetaAccessToken(tenantId)

// ‚ùå NEVER - Ignore token expiration
const token = connection.access_token

// ‚úÖ ALWAYS - Check expiration and refresh
if (isExpired(connection.expires_at)) {
  token = await refreshToken(tenantId)
} else {
  token = await decryptToken(connection.access_token_encrypted)
}

// ‚ùå NEVER - Log tokens or sensitive data
console.log('Token:', accessToken)

// ‚úÖ ALWAYS - Log only metadata
console.log('Token refreshed for tenant:', tenantId)
```

---

## Agent Checklist (EVERY Phase)

Before completing any phase, verify:

### Tenant Isolation ‚úì
- [ ] All database queries use `withTenant()`
- [ ] All cache operations use `createTenantCache()`
- [ ] All background jobs include `tenantId` in payload
- [ ] All file storage uses tenant-prefixed paths
- [ ] Isolation tests are included

### Permission Checks ‚úì
- [ ] All API routes use `getTenantContext()` first
- [ ] All write operations check appropriate permissions
- [ ] UI elements hidden based on permissions
- [ ] Permission denied returns 403 with clear error
- [ ] Super admin routes require `isSuperAdmin()` check

### Portability ‚úì
- [ ] CLI setup command created (if applicable)
- [ ] Setup documentation written (if applicable)
- [ ] Web configuration minimized (API keys only)
- [ ] New user can set up in < 15 minutes

### Code Quality ‚úì
- [ ] `npx tsc --noEmit` passes
- [ ] Files under 650 lines
- [ ] Tests pass

### Communications ‚úì (Email-sending phases only)
- [ ] All email content from tenant templates (no hardcoded strings)
- [ ] All sender addresses from tenant configuration (no hardcoded emails)
- [ ] Email queues use atomic claim pattern (`FOR UPDATE SKIP LOCKED`)
- [ ] Queue entries include `tenant_id` for isolation

### SMS ‚úì (SMS-enabled phases only)
- [ ] SMS is OFF by default for tenants
- [ ] SMS only used for platform notifications (NO marketing)
- [ ] Opt-out checked before every send
- [ ] STOP keyword webhook handles opt-outs automatically
- [ ] Quiet hours enforced (9pm-9am default)
- [ ] SMS queue uses same atomic claim pattern as email
- [ ] 160-character limit enforced in templates
- [ ] Twilio credentials encrypted at rest

### Integrations ‚úì (Third-party integration phases)
- [ ] Credentials stored encrypted (AES-256-GCM)
- [ ] Webhook signatures verified before processing
- [ ] Tenant context included in webhook lookups
- [ ] Platform-level vs tenant-level credentials separated
- [ ] Token refresh scheduled for OAuth integrations

### AI Agents ‚úì (AI Assistant phases only)
- [ ] All agent data scoped to tenant (agent_id + tenant_id)
- [ ] Memory embeddings generated for semantic search (3072-dim)
- [ ] Autonomy checks before high-stakes actions
- [ ] Action logging for all agent operations
- [ ] Personality prompts built from agent config
- [ ] RAG context included in message processing
- [ ] Multi-channel events routed with tenant context
- [ ] Voice calls use real-time WebSocket handling
- [ ] Approval requests created for human_required actions
- [ ] Feedback processed for correction detection
- [ ] Health checks implemented for critical integrations
- [ ] Error states logged and recoverable
- [ ] Queue UI available for viewing/managing emails

### Tax Compliance ‚úì (Phase 4D and tax-related features)
- [ ] TINs encrypted with AES-256-GCM before storage
- [ ] Only last 4 digits of TIN stored in plaintext
- [ ] Every TIN decryption logged with IP/user agent
- [ ] SSN/EIN format validation before storage
- [ ] Known invalid patterns rejected (000-xx-xxxx, 666-xx-xxxx, etc.)
- [ ] Form status transitions validated (no backward moves)
- [ ] Filed forms cannot be voided - only corrected
- [ ] Corrections reference original form
- [ ] $600 threshold check before 1099 generation
- [ ] W-9 must exist before 1099 generation
- [ ] Audit trail immutable for all tax actions
- [ ] Payer info from environment variables (not hardcoded)
- [ ] W-9 reminder automation implemented
- [ ] Admin tax dashboard shows accurate stats

---

## Commerce Complete System Patterns

### Subscription Provider Abstraction

All subscription operations must go through the provider abstraction layer:

```typescript
interface SubscriptionProvider {
  // Core CRUD
  getSubscription(id: string): Promise<Subscription>
  listSubscriptions(filters: SubscriptionFilters): Promise<PaginatedResult<Subscription>>

  // Lifecycle
  pauseSubscription(id: string, reason: string, resumeDate?: Date): Promise<void>
  resumeSubscription(id: string): Promise<void>
  cancelSubscription(id: string, reason: string): Promise<void>
  skipNextOrder(id: string): Promise<void>

  // Sync
  syncFromProvider(): Promise<SyncResult>
  pushToProvider(subscription: Subscription): Promise<void>
}

// ‚úÖ ALWAYS - Use provider abstraction
const provider = getSubscriptionProvider(tenantId)
const subscription = await provider.getSubscription(subscriptionId)

// ‚úÖ ALWAYS - Check tenant isolation
const subscriptions = await withTenant(tenantId, () =>
  provider.listSubscriptions({ status: 'active' })
)

// ‚ùå NEVER - Direct Loop/Recharge API calls without abstraction
const response = await fetch('https://api.loop.com/subscriptions/' + id)
```

### Save Flow (Retention) Patterns

When a customer attempts to cancel:

```typescript
interface SaveFlowConfig {
  tenantId: string
  flowType: 'cancellation' | 'winback' | 'at_risk'
  steps: SaveFlowStep[]
  offers: SaveFlowOffer[]
  isEnabled: boolean
}

interface SaveFlowStep {
  type: 'show_reasons' | 'offer_pause' | 'offer_discount' | 'confirm_cancel'
  config: StepConfig
}

// ‚úÖ ALWAYS - Track save attempt outcomes
async function recordSaveAttempt(
  tenantId: string,
  subscriptionId: string,
  flowId: string,
  outcome: 'saved' | 'cancelled' | 'pending',
  offerAccepted?: string
) {
  await withTenant(tenantId, () =>
    sql`INSERT INTO subscription_save_attempts
        (tenant_id, subscription_id, flow_id, outcome, offer_accepted, created_at)
        VALUES (${tenantId}, ${subscriptionId}, ${flowId}, ${outcome}, ${offerAccepted}, NOW())`
  )
}
```

### Review Provider Abstraction

Support both Internal and Yotpo review systems:

```typescript
interface ReviewProvider {
  getReviews(filters: ReviewFilters): Promise<PaginatedResult<Review>>
  getReview(id: string): Promise<Review>
  moderateReview(id: string, action: 'approve' | 'reject'): Promise<void>
  respondToReview(reviewId: string, response: string): Promise<ReviewResponse>
  syncFromProvider(): Promise<SyncResult>
}

// ‚úÖ ALWAYS - Use provider abstraction
const provider = getReviewProvider(tenantId)
await provider.moderateReview(reviewId, 'approve')

// ‚úÖ ALWAYS - Queue review request emails through the system
await queueReviewRequestEmail({
  tenantId,
  orderId,
  customerEmail,
  productId,
  scheduledAt: addDays(orderDeliveredAt, 7) // 7 days after delivery
})

// ‚ùå NEVER - Direct Yotpo API without abstraction
await fetch('https://api.yotpo.com/...')
```

### Review Email Queue Pattern

All review-related emails go through the queue:

```typescript
interface ReviewEmailQueue {
  id: string
  tenantId: string
  customerEmail: string
  orderId: string
  productId: string
  templateId: string
  status: 'pending' | 'sent' | 'delivered' | 'opened' | 'clicked' | 'failed'
  scheduledAt: Date
  sentAt?: Date
}

// ‚úÖ ALWAYS - Use queue for review emails
await withTenant(tenantId, () =>
  sql`INSERT INTO review_email_queue
      (tenant_id, customer_email, order_id, product_id, template_id, status, scheduled_at)
      VALUES (${tenantId}, ${email}, ${orderId}, ${productId}, ${templateId}, 'pending', ${scheduledAt})`
)

// ‚úÖ ALWAYS - Track email lifecycle events
async function updateEmailStatus(
  queueId: string,
  status: 'sent' | 'delivered' | 'opened' | 'clicked',
  timestamp: Date
) {
  await sql`UPDATE review_email_queue SET ${status}_at = ${timestamp} WHERE id = ${queueId}`
}
```

### Incentive Code Management

Track discount codes issued for reviews:

```typescript
interface ReviewIncentiveCode {
  id: string
  tenantId: string
  code: string
  reviewId: string
  customerEmail: string
  discountType: 'percentage' | 'fixed'
  discountValue: number
  status: 'active' | 'redeemed' | 'expired'
  expiresAt: Date
}

// ‚úÖ ALWAYS - Generate unique codes
function generateIncentiveCode(tenantId: string, prefix: string = 'REVIEW'): string {
  const unique = crypto.randomBytes(4).toString('hex').toUpperCase()
  return `${prefix}-${unique}`
}

// ‚úÖ ALWAYS - Track redemptions
async function redeemIncentiveCode(
  tenantId: string,
  code: string,
  orderId: string
) {
  await withTenant(tenantId, () =>
    sql`UPDATE review_incentive_codes
        SET status = 'redeemed', redeemed_at = NOW(), redeemed_order_id = ${orderId}
        WHERE tenant_id = ${tenantId} AND code = ${code} AND status = 'active'`
  )
}
```

### Analytics Pre-Computation Pattern

All commerce analytics should use pre-computed tables:

```typescript
// ‚úÖ ALWAYS - Pre-compute expensive aggregations
const subscriptionAnalyticsJob = task({
  id: 'subscription-analytics-daily',
  run: async (payload: { tenantId: string }) => {
    await withTenant(payload.tenantId, async () => {
      // Pre-compute MRR, churn rate, cohort data
      await sql`
        INSERT INTO subscription_metrics_daily (tenant_id, metric_date, mrr, arr, active_count, churn_rate)
        SELECT
          ${payload.tenantId},
          CURRENT_DATE,
          SUM(price_cents) as mrr,
          SUM(price_cents) * 12 as arr,
          COUNT(*) FILTER (WHERE status = 'active'),
          -- Churn calculation
          COUNT(*) FILTER (WHERE cancelled_at >= CURRENT_DATE - 30)::FLOAT /
            NULLIF(COUNT(*) FILTER (WHERE created_at < CURRENT_DATE - 30), 0)
        FROM subscriptions
        WHERE status IN ('active', 'cancelled')
        ON CONFLICT (tenant_id, metric_date) DO UPDATE SET
          mrr = EXCLUDED.mrr,
          arr = EXCLUDED.arr,
          updated_at = NOW()
      `
    })
  }
})

// ‚ùå NEVER - Real-time aggregation for dashboards
const mrr = await sql`SELECT SUM(price_cents) FROM subscriptions WHERE status = 'active'`
```

### Google Feed Generation Pattern

Feed generation must be tenant-isolated:

```typescript
interface GoogleFeedProduct {
  id: string
  title: string
  description: string
  link: string
  image_link: string
  price: string
  availability: 'in_stock' | 'out_of_stock'
  brand: string
  google_product_category?: string
  gtin?: string
  mpn?: string
}

// ‚úÖ ALWAYS - Generate tenant-specific feed URL with token
function getFeedUrl(tenantId: string): string {
  const token = generateFeedToken(tenantId) // Secure, rotatable token
  return `https://api.platform.com/feeds/google/${token}/products.xml`
}

// ‚úÖ ALWAYS - Apply tenant exclusion rules
async function generateFeed(tenantId: string): Promise<GoogleFeedProduct[]> {
  const settings = await getFeedSettings(tenantId)
  const products = await withTenant(tenantId, () =>
    sql`SELECT * FROM products WHERE is_active = true`
  )

  return products
    .filter(p => !isExcluded(p, settings.exclusionRules))
    .map(p => mapToGoogleFormat(p, settings))
}
```

### Survey Response Attribution

Survey responses should integrate with the attribution system:

```typescript
interface SurveyResponse {
  id: string
  tenantId: string
  orderId: string
  responseOption: string
  responseText?: string
  createdAt: Date
}

// ‚úÖ ALWAYS - Map survey channels to attribution sources
const SURVEY_TO_ATTRIBUTION_MAP: Record<string, string> = {
  'Instagram': 'meta.instagram',
  'TikTok': 'tiktok',
  'Facebook': 'meta.facebook',
  'Google Search': 'google.search',
  'YouTube': 'google.youtube',
  'Podcast': 'organic.podcast',
  'Friend/Family': 'organic.referral',
}

// ‚úÖ ALWAYS - Correlate survey data with ad platform data
async function getBlendedAttribution(
  tenantId: string,
  dateRange: DateRange
): Promise<BlendedAttribution> {
  const [surveyData, adData] = await Promise.all([
    getSurveyAttribution(tenantId, dateRange),
    getAdPlatformAttribution(tenantId, dateRange)
  ])

  return blendAttribution(surveyData, adData, { surveyWeight: 0.4, adWeight: 0.6 })
}
```

### Commerce Checklist

Before implementing any commerce feature, verify:

- [ ] Subscription operations use provider abstraction
- [ ] Save flows track success/failure metrics
- [ ] Review emails go through queue with tracking
- [ ] Incentive codes are unique and tracked
- [ ] Analytics use pre-computed tables
- [ ] Google Feed is tenant-isolated with secure URLs
- [ ] Survey responses integrate with attribution
- [ ] All database queries use `withTenant()`
- [ ] Email templates are tenant-customizable
- [ ] Provider credentials stored per-tenant

---

## Customer Portal Patterns

**CRITICAL**: The customer portal is fully white-labeled. All UI, text, icons, and theming must be customizable per tenant. Never hardcode any visual or text content.

### Portal Theming Database Schema

```typescript
// packages/portal/schema/theme.ts

interface PortalThemeConfig {
  tenantId: string

  // Colors
  primaryColor: string       // #374d42 (brand green)
  secondaryColor: string     // #828282
  backgroundColor: string    // #f1f1f0
  cardBackgroundColor: string // #ffffff
  borderColor: string        // #3d3d3d
  accentColor: string        // For highlights
  errorColor: string         // #dc2626
  successColor: string       // #16a34a

  // Typography
  fontFamily: string         // e.g., 'Space Grotesk, sans-serif'
  headingFontFamily?: string // Optional separate heading font
  baseFontSize: number       // 16
  lineHeight: number         // 1.15

  // Layout
  maxContentWidth: string    // '1440px'
  cardBorderRadius: string   // '0px' for RAWDOG style
  buttonBorderRadius: string // '0px'
  spacing: 'compact' | 'normal' | 'relaxed'

  // Branding
  logoUrl?: string
  logoHeight?: number
  faviconUrl?: string

  // Custom CSS (advanced)
  customCss?: string
}

// ‚úÖ CORRECT - Create theme table per tenant schema
CREATE TABLE portal_theme_config (
  tenant_id UUID PRIMARY KEY REFERENCES tenants(id),
  primary_color VARCHAR(7) DEFAULT '#374d42',
  secondary_color VARCHAR(7) DEFAULT '#828282',
  background_color VARCHAR(7) DEFAULT '#f1f1f0',
  card_background_color VARCHAR(7) DEFAULT '#ffffff',
  border_color VARCHAR(7) DEFAULT '#3d3d3d',
  accent_color VARCHAR(7) DEFAULT '#374d42',
  error_color VARCHAR(7) DEFAULT '#dc2626',
  success_color VARCHAR(7) DEFAULT '#16a34a',
  font_family VARCHAR(255) DEFAULT 'Space Grotesk, sans-serif',
  heading_font_family VARCHAR(255),
  base_font_size INTEGER DEFAULT 16,
  line_height DECIMAL(3,2) DEFAULT 1.15,
  max_content_width VARCHAR(20) DEFAULT '1440px',
  card_border_radius VARCHAR(20) DEFAULT '0px',
  button_border_radius VARCHAR(20) DEFAULT '0px',
  spacing VARCHAR(20) DEFAULT 'normal',
  logo_url TEXT,
  logo_height INTEGER,
  favicon_url TEXT,
  custom_css TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

// ‚úÖ CORRECT - Get theme with tenant isolation
export async function getPortalTheme(tenantId: string): Promise<PortalThemeConfig> {
  return await withTenant(tenantId, async () => {
    const result = await sql`SELECT * FROM portal_theme_config WHERE tenant_id = ${tenantId}`
    return result.rows[0] || getDefaultTheme()
  })
}

// ‚ùå NEVER - Query theme without tenant context
const theme = await sql`SELECT * FROM portal_theme_config LIMIT 1`
```

### Icon Customization Schema

```typescript
// packages/portal/schema/icons.ts

interface PortalIconConfig {
  tenantId: string
  iconSet: 'rawdog' | 'lucide' | 'heroicons' | 'custom'
  customIcons?: Record<string, string> // iconKey -> SVG URL or inline SVG
}

// Icon mapping table
CREATE TABLE portal_icon_config (
  tenant_id UUID PRIMARY KEY REFERENCES tenants(id),
  icon_set VARCHAR(50) DEFAULT 'rawdog',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE portal_custom_icons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  icon_key VARCHAR(50) NOT NULL,  -- 'orders', 'subscriptions', 'profile', etc.
  icon_type VARCHAR(20) NOT NULL, -- 'svg_url' or 'svg_inline'
  icon_value TEXT NOT NULL,       -- URL or SVG content
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(tenant_id, icon_key)
);

// ‚úÖ CORRECT - Get icon with fallback chain
export async function getPortalIcon(tenantId: string, iconKey: string): Promise<string> {
  return await withTenant(tenantId, async () => {
    // 1. Check for custom icon
    const custom = await sql`
      SELECT icon_value, icon_type FROM portal_custom_icons
      WHERE tenant_id = ${tenantId} AND icon_key = ${iconKey}
    `
    if (custom.rows[0]) {
      return custom.rows[0].icon_type === 'svg_url'
        ? await fetchSvg(custom.rows[0].icon_value)
        : custom.rows[0].icon_value
    }

    // 2. Fall back to icon set
    const config = await sql`SELECT icon_set FROM portal_icon_config WHERE tenant_id = ${tenantId}`
    const iconSet = config.rows[0]?.icon_set || 'rawdog'

    return getIconFromSet(iconSet, iconKey)
  })
}
```

### Content Customization Schema

```typescript
// packages/portal/schema/content.ts

// All portal text strings are customizable
CREATE TABLE portal_content_strings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  content_key VARCHAR(100) NOT NULL, -- e.g., 'orders.title', 'subscriptions.pause_button'
  content_value TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(tenant_id, content_key)
);

// Default content strings
const DEFAULT_CONTENT: Record<string, string> = {
  'dashboard.title': 'My Account',
  'dashboard.welcome': 'Welcome back, {{firstName}}',
  'orders.title': 'Orders',
  'orders.empty': 'No orders yet',
  'orders.track_shipment': 'Track Shipment',
  'subscriptions.title': 'Subscriptions',
  'subscriptions.pause': 'Pause',
  'subscriptions.resume': 'Resume',
  'subscriptions.cancel': 'Cancel Subscription',
  'subscriptions.skip': 'Skip Next Order',
  'profile.title': 'Profile',
  'profile.update': 'Update Profile',
  'addresses.title': 'Shipping Addresses',
  'addresses.add': 'Add Address',
  'store_credit.title': 'Store Credit',
  'store_credit.balance': 'Available Balance',
}

// ‚úÖ CORRECT - Get content with variable substitution
export async function getPortalContent(
  tenantId: string,
  contentKey: string,
  variables?: Record<string, string>
): Promise<string> {
  const custom = await withTenant(tenantId, async () => {
    return sql`SELECT content_value FROM portal_content_strings
               WHERE tenant_id = ${tenantId} AND content_key = ${contentKey}`
  })

  let content = custom.rows[0]?.content_value || DEFAULT_CONTENT[contentKey] || contentKey

  // Substitute variables
  if (variables) {
    Object.entries(variables).forEach(([key, value]) => {
      content = content.replace(new RegExp(`{{${key}}}`, 'g'), escapeHtml(value))
    })
  }

  return content
}

// ‚ùå NEVER - Hardcode content strings
return <h1>My Account</h1>

// ‚úÖ ALWAYS - Use content system
const title = await getPortalContent(tenantId, 'dashboard.title')
return <h1>{title}</h1>
```

### Custom Domain Routing Pattern

```typescript
// packages/portal/routing/domain.ts

// Custom domain lookup table
CREATE TABLE portal_custom_domains (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  domain VARCHAR(255) NOT NULL UNIQUE,
  subdomain VARCHAR(100),               -- For subdomain.platform.com style
  ssl_status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'active', 'failed'
  ssl_issued_at TIMESTAMP,
  verified_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

// ‚úÖ CORRECT - Middleware for custom domain resolution
export async function resolveTenantFromDomain(hostname: string): Promise<string | null> {
  // 1. Check custom domain table
  const custom = await sql`
    SELECT tenant_id FROM portal_custom_domains
    WHERE domain = ${hostname}
      AND ssl_status = 'active'
      AND verified_at IS NOT NULL
  `
  if (custom.rows[0]) {
    return custom.rows[0].tenant_id
  }

  // 2. Check subdomain pattern (e.g., acme.portal.platform.com)
  const subdomainMatch = hostname.match(/^([a-z0-9-]+)\.portal\./)
  if (subdomainMatch) {
    const tenant = await sql`
      SELECT id FROM tenants WHERE slug = ${subdomainMatch[1]} AND is_active = true
    `
    return tenant.rows[0]?.id || null
  }

  return null
}

// ‚úÖ CORRECT - Domain verification via DNS TXT record
export async function verifyDomainOwnership(
  tenantId: string,
  domain: string
): Promise<{ verified: boolean; error?: string }> {
  const expectedValue = `platform-verify=${tenantId}`

  try {
    const records = await dns.resolveTxt(domain)
    const verified = records.some(record =>
      record.join('').includes(expectedValue)
    )

    if (verified) {
      await sql`
        UPDATE portal_custom_domains
        SET verified_at = NOW()
        WHERE tenant_id = ${tenantId} AND domain = ${domain}
      `
    }

    return { verified }
  } catch (error) {
    return { verified: false, error: 'DNS lookup failed' }
  }
}

// ‚úÖ CORRECT - SSL provisioning via Vercel API
export async function provisionSSL(
  tenantId: string,
  domain: string
): Promise<{ success: boolean }> {
  // Add domain to Vercel project
  const response = await fetch(`https://api.vercel.com/v10/projects/${PROJECT_ID}/domains`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${VERCEL_TOKEN}` },
    body: JSON.stringify({ name: domain })
  })

  if (response.ok) {
    await sql`
      UPDATE portal_custom_domains
      SET ssl_status = 'active', ssl_issued_at = NOW()
      WHERE tenant_id = ${tenantId} AND domain = ${domain}
    `
    return { success: true }
  }

  return { success: false }
}
```

### Feature Toggle Implementation Pattern

```typescript
// packages/portal/features/toggles.ts

type PortalFeature =
  | 'orders'
  | 'subscriptions'
  | 'addresses'
  | 'profile'
  | 'store_credit'
  | 'rewards'           // Optional loyalty program
  | 'referrals'         // Optional referral program
  | 'subscription_pause'
  | 'subscription_skip'
  | 'subscription_cancel_self_serve'
  | 'subscription_reschedule'
  | 'subscription_payment_update'
  | 'subscription_address_update'

CREATE TABLE portal_feature_flags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES tenants(id),
  feature_key VARCHAR(50) NOT NULL,
  is_enabled BOOLEAN DEFAULT true,
  config JSONB DEFAULT '{}', -- Feature-specific config
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(tenant_id, feature_key)
);

// Default feature states
const DEFAULT_FEATURES: Record<PortalFeature, boolean> = {
  orders: true,
  subscriptions: true,
  addresses: true,
  profile: true,
  store_credit: true,
  rewards: false,           // Off by default
  referrals: false,         // Off by default
  subscription_pause: true,
  subscription_skip: true,
  subscription_cancel_self_serve: true,
  subscription_reschedule: true,
  subscription_payment_update: true,
  subscription_address_update: true,
}

// ‚úÖ CORRECT - Check feature with tenant context
export async function isFeatureEnabled(
  tenantId: string,
  feature: PortalFeature
): Promise<boolean> {
  return await withTenant(tenantId, async () => {
    const result = await sql`
      SELECT is_enabled FROM portal_feature_flags
      WHERE tenant_id = ${tenantId} AND feature_key = ${feature}
    `
    return result.rows[0]?.is_enabled ?? DEFAULT_FEATURES[feature] ?? false
  })
}

// ‚úÖ CORRECT - Get all features for portal rendering
export async function getPortalFeatures(tenantId: string): Promise<Record<PortalFeature, boolean>> {
  return await withTenant(tenantId, async () => {
    const result = await sql`
      SELECT feature_key, is_enabled FROM portal_feature_flags
      WHERE tenant_id = ${tenantId}
    `

    const custom = Object.fromEntries(
      result.rows.map(r => [r.feature_key, r.is_enabled])
    )

    return { ...DEFAULT_FEATURES, ...custom }
  })
}

// ‚úÖ CORRECT - Use in React component
export function SubscriptionCard({ tenantId, subscription }) {
  const [features, setFeatures] = useState<Record<PortalFeature, boolean>>({})

  useEffect(() => {
    getPortalFeatures(tenantId).then(setFeatures)
  }, [tenantId])

  return (
    <div>
      {features.subscription_pause && (
        <button onClick={handlePause}>Pause</button>
      )}
      {features.subscription_skip && (
        <button onClick={handleSkip}>Skip Next</button>
      )}
      {features.subscription_cancel_self_serve && (
        <button onClick={handleCancel}>Cancel</button>
      )}
    </div>
  )
}

// ‚ùå NEVER - Hardcode feature availability
const canPause = true

// ‚úÖ ALWAYS - Check feature flag
const canPause = await isFeatureEnabled(tenantId, 'subscription_pause')
```

### Portal Theme CSS Generation Pattern

```typescript
// packages/portal/theme/css.ts

// ‚úÖ CORRECT - Generate CSS variables from theme config
export function generateThemeCss(theme: PortalThemeConfig): string {
  return `
    :root {
      --portal-primary: ${theme.primaryColor};
      --portal-secondary: ${theme.secondaryColor};
      --portal-background: ${theme.backgroundColor};
      --portal-card-bg: ${theme.cardBackgroundColor};
      --portal-border: ${theme.borderColor};
      --portal-accent: ${theme.accentColor};
      --portal-error: ${theme.errorColor};
      --portal-success: ${theme.successColor};

      --portal-font-family: ${theme.fontFamily};
      --portal-heading-font: ${theme.headingFontFamily || theme.fontFamily};
      --portal-font-size: ${theme.baseFontSize}px;
      --portal-line-height: ${theme.lineHeight};

      --portal-max-width: ${theme.maxContentWidth};
      --portal-card-radius: ${theme.cardBorderRadius};
      --portal-button-radius: ${theme.buttonBorderRadius};
    }

    ${theme.customCss || ''}
  `
}

// ‚úÖ CORRECT - Inject theme in layout
export function PortalLayout({ tenantId, children }) {
  const [theme, setTheme] = useState<PortalThemeConfig | null>(null)

  useEffect(() => {
    getPortalTheme(tenantId).then(setTheme)
  }, [tenantId])

  if (!theme) return <LoadingSpinner />

  return (
    <>
      <style dangerouslySetInnerHTML={{ __html: generateThemeCss(theme) }} />
      <div className="portal-container">
        {theme.logoUrl && (
          <img src={theme.logoUrl} height={theme.logoHeight || 40} alt="Logo" />
        )}
        {children}
      </div>
    </>
  )
}
```

### Shopify Customer Account API OAuth Pattern

```typescript
// packages/portal/auth/shopify-oauth.ts

// ‚úÖ CORRECT - Tenant-isolated OAuth configuration
interface ShopifyOAuthConfig {
  tenantId: string
  shopId: string
  clientId: string
  clientSecretEncrypted: string
  redirectUri: string
}

// OAuth PKCE flow for customer authentication
export async function initiateShopifyLogin(
  tenantId: string,
  redirectAfterLogin: string
): Promise<string> {
  const config = await getShopifyOAuthConfig(tenantId)

  // Generate PKCE challenge
  const codeVerifier = generateCodeVerifier()
  const codeChallenge = await generateCodeChallenge(codeVerifier)

  // Store verifier in session (Redis)
  const cache = createTenantCache(tenantId)
  const stateId = crypto.randomUUID()
  await cache.set(`oauth:${stateId}`, JSON.stringify({
    codeVerifier,
    redirectAfterLogin,
    tenantId
  }), 600) // 10 minute TTL

  const authUrl = new URL(`https://shopify.com/${config.shopId}/auth/oauth/authorize`)
  authUrl.searchParams.set('client_id', config.clientId)
  authUrl.searchParams.set('redirect_uri', config.redirectUri)
  authUrl.searchParams.set('response_type', 'code')
  authUrl.searchParams.set('scope', 'openid email customer-account-api:full')
  authUrl.searchParams.set('code_challenge', codeChallenge)
  authUrl.searchParams.set('code_challenge_method', 'S256')
  authUrl.searchParams.set('state', stateId)

  return authUrl.toString()
}

// ‚úÖ CORRECT - Handle OAuth callback with tenant context
export async function handleShopifyCallback(
  code: string,
  state: string
): Promise<{ accessToken: string; customerId: string; redirectTo: string }> {
  // Retrieve and delete state (one-time use)
  const stateData = await getAndDeleteOAuthState(state)
  if (!stateData) throw new Error('Invalid or expired state')

  const { tenantId, codeVerifier, redirectAfterLogin } = stateData
  const config = await getShopifyOAuthConfig(tenantId)

  // Exchange code for tokens
  const tokenResponse = await fetch(
    `https://shopify.com/${config.shopId}/auth/oauth/token`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        client_id: config.clientId,
        client_secret: await decrypt(config.clientSecretEncrypted),
        code,
        redirect_uri: config.redirectUri,
        code_verifier: codeVerifier,
      }),
    }
  )

  const tokens = await tokenResponse.json()

  // Store tokens encrypted in tenant-scoped session
  await storeCustomerSession(tenantId, tokens)

  return {
    accessToken: tokens.access_token,
    customerId: extractCustomerId(tokens.id_token),
    redirectTo: redirectAfterLogin
  }
}
```

### Portal Anti-Patterns

```typescript
// ‚ùå NEVER - Hardcode colors or styles
<div style={{ backgroundColor: '#f1f1f0', color: '#374d42' }}>

// ‚úÖ ALWAYS - Use CSS variables from theme
<div style={{ backgroundColor: 'var(--portal-background)', color: 'var(--portal-primary)' }}>

// ‚ùå NEVER - Hardcode text strings
<h1>My Account</h1>
<button>Pause Subscription</button>

// ‚úÖ ALWAYS - Use content customization system
<h1>{content['dashboard.title']}</h1>
<button>{content['subscriptions.pause']}</button>

// ‚ùå NEVER - Show features without checking flags
<button onClick={handleCancel}>Cancel</button>

// ‚úÖ ALWAYS - Check feature flags
{features.subscription_cancel_self_serve && (
  <button onClick={handleCancel}>Cancel</button>
)}

// ‚ùå NEVER - Query portal config without tenant
const theme = await sql`SELECT * FROM portal_theme_config LIMIT 1`

// ‚úÖ ALWAYS - Include tenant context
const theme = await withTenant(tenantId, () =>
  sql`SELECT * FROM portal_theme_config WHERE tenant_id = ${tenantId}`
)

// ‚ùå NEVER - Use default icons without checking custom icons
import { PackageIcon } from '@/components/ui/icons'
return <PackageIcon />

// ‚úÖ ALWAYS - Use icon system with custom fallback
const iconSvg = await getPortalIcon(tenantId, 'orders')
return <div dangerouslySetInnerHTML={{ __html: iconSvg }} />

// ‚ùå NEVER - Hardcode Shopify shop ID
const shopId = '12345678'

// ‚úÖ ALWAYS - Get from tenant configuration
const config = await getShopifyOAuthConfig(tenantId)
const shopId = config.shopId
```

### Portal Checklist

Before implementing any portal feature, verify:

- [ ] All visual styling uses CSS variables from theme config
- [ ] All text strings use the content customization system
- [ ] All icons use the icon system with tenant fallback
- [ ] All features check feature flags before rendering
- [ ] Custom domain routing respects SSL verification
- [ ] OAuth state is tenant-scoped and one-time use
- [ ] Customer sessions are tenant-isolated
- [ ] All database queries use `withTenant()`
- [ ] Theme changes apply without page reload
- [ ] Feature toggles can be changed in admin without deploy

---

## Shopify Integration Patterns

**CRITICAL**: The platform integrates with Shopify through a single multi-tenant Shopify App. All stores connect through one App ID with tenant-isolated data storage.

### OAuth Flow for Tenant Store Connections

```typescript
// packages/integrations/shopify/oauth.ts

export async function handleShopifyInstall(
  tenantId: string,
  shopDomain: string,
  authorizationCode: string
): Promise<ShopifyCredentials> {
  // 1. Exchange code for access token
  const tokenResponse = await fetch(
    `https://${shopDomain}/admin/oauth/access_token`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        client_id: process.env.SHOPIFY_APP_CLIENT_ID, // Shared App ID
        client_secret: process.env.SHOPIFY_APP_CLIENT_SECRET,
        code: authorizationCode
      })
    }
  )

  const { access_token, scope } = await tokenResponse.json()

  // 2. Encrypt access token (tenant-specific)
  const encryptedToken = await encryptToken(access_token, tenantId)

  // 3. Store credentials with tenant isolation
  await withTenant(tenantId, async () => {
    await sql`
      INSERT INTO shopify_credentials (
        tenant_id, shop_domain, access_token_encrypted,
        scopes, installed_at, status
      )
      VALUES (
        ${tenantId}, ${shopDomain}, ${encryptedToken},
        ${scope.split(',')}, now(), 'active'
      )
      ON CONFLICT (tenant_id, shop_domain)
      DO UPDATE SET
        access_token_encrypted = EXCLUDED.access_token_encrypted,
        scopes = EXCLUDED.scopes,
        updated_at = now()
    `
  })

  // 4. Register webhooks for this shop
  await registerShopifyWebhooks(tenantId, shopDomain, access_token)

  return { shopDomain, scopes: scope.split(',') }
}

// ‚úÖ CORRECT - Get credentials with decryption
export async function getShopifyCredentials(
  tenantId: string,
  shopDomain?: string
): Promise<ShopifyCredentials | null> {
  const result = await withTenant(tenantId, async () => {
    if (shopDomain) {
      return sql`
        SELECT * FROM shopify_credentials
        WHERE tenant_id = ${tenantId} AND shop_domain = ${shopDomain}
      `
    }
    // Get primary store for tenant
    return sql`
      SELECT * FROM shopify_credentials
      WHERE tenant_id = ${tenantId} AND is_primary = true
    `
  })

  if (!result.rows[0]) return null

  // Decrypt token
  const accessToken = await decryptToken(
    result.rows[0].access_token_encrypted,
    tenantId
  )

  return {
    shopDomain: result.rows[0].shop_domain,
    accessToken,
    scopes: result.rows[0].scopes
  }
}
```

### Token Encryption Pattern

```typescript
// packages/integrations/shopify/encryption.ts

import crypto from 'crypto'

// AES-256-GCM with tenant-specific key derivation
export async function encryptToken(
  accessToken: string,
  tenantId: string
): Promise<string> {
  // Derive tenant-specific key from master key
  const masterKey = process.env.SHOPIFY_TOKEN_ENCRYPTION_KEY! // 32 bytes
  const tenantKey = crypto.pbkdf2Sync(
    masterKey,
    tenantId,
    100000,
    32,
    'sha256'
  )

  // Generate IV
  const iv = crypto.randomBytes(16)

  // Encrypt
  const cipher = crypto.createCipheriv('aes-256-gcm', tenantKey, iv)
  let encrypted = cipher.update(accessToken, 'utf8', 'hex')
  encrypted += cipher.final('hex')
  const authTag = cipher.getAuthTag()

  // Return IV + authTag + ciphertext
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`
}

export async function decryptToken(
  encryptedData: string,
  tenantId: string
): Promise<string> {
  const [ivHex, authTagHex, encrypted] = encryptedData.split(':')

  // Derive same tenant-specific key
  const masterKey = process.env.SHOPIFY_TOKEN_ENCRYPTION_KEY!
  const tenantKey = crypto.pbkdf2Sync(
    masterKey,
    tenantId,
    100000,
    32,
    'sha256'
  )

  const iv = Buffer.from(ivHex, 'hex')
  const authTag = Buffer.from(authTagHex, 'hex')

  const decipher = crypto.createDecipheriv('aes-256-gcm', tenantKey, iv)
  decipher.setAuthTag(authTag)

  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')

  return decrypted
}
```

### Webhook Handling Pattern

```typescript
// packages/integrations/shopify/webhooks.ts

export async function handleShopifyWebhook(
  request: Request
): Promise<Response> {
  // 1. Extract shop domain from header
  const shopDomain = request.headers.get('x-shopify-shop-domain')
  const topic = request.headers.get('x-shopify-topic')
  const hmac = request.headers.get('x-shopify-hmac-sha256')

  if (!shopDomain || !topic || !hmac) {
    return new Response('Missing headers', { status: 400 })
  }

  // 2. Verify HMAC signature
  const body = await request.text()
  const isValid = verifyHmac(body, hmac, process.env.SHOPIFY_APP_CLIENT_SECRET!)

  if (!isValid) {
    console.error('Invalid Shopify webhook HMAC', { shopDomain, topic })
    return new Response('Invalid signature', { status: 401 })
  }

  // 3. Route to tenant
  const tenantId = await getTenantByShopDomain(shopDomain)
  if (!tenantId) {
    console.error('Unknown shop domain', { shopDomain })
    return new Response('Unknown shop', { status: 404 })
  }

  // 4. Dispatch to handler
  const payload = JSON.parse(body)
  await dispatchWebhookEvent(tenantId, topic, payload)

  return new Response('OK', { status: 200 })
}

// HMAC verification
function verifyHmac(body: string, hmac: string, secret: string): boolean {
  const computed = crypto
    .createHmac('sha256', secret)
    .update(body, 'utf8')
    .digest('base64')

  return crypto.timingSafeEqual(
    Buffer.from(computed),
    Buffer.from(hmac)
  )
}

// Shop domain ‚Üí tenant lookup (cached)
async function getTenantByShopDomain(shopDomain: string): Promise<string | null> {
  const cacheKey = `shopify:shop:${shopDomain}`
  const cached = await redis.get(cacheKey)
  if (cached) return cached

  const result = await sql`
    SELECT tenant_id FROM shopify_credentials
    WHERE shop_domain = ${shopDomain} AND status = 'active'
    LIMIT 1
  `

  if (result.rows[0]) {
    await redis.set(cacheKey, result.rows[0].tenant_id, 'EX', 3600) // 1 hour
    return result.rows[0].tenant_id
  }

  return null
}

// Dispatch to background job
async function dispatchWebhookEvent(
  tenantId: string,
  topic: string,
  payload: unknown
): Promise<void> {
  const eventType = topicToEventType(topic)

  await jobProvider.send(eventType, {
    tenantId,
    topic,
    payload,
    receivedAt: new Date().toISOString()
  })
}

function topicToEventType(topic: string): string {
  const mapping: Record<string, string> = {
    'orders/create': 'shopify.order.created',
    'orders/updated': 'shopify.order.updated',
    'orders/paid': 'shopify.order.paid',
    'orders/fulfilled': 'shopify.order.fulfilled',
    'refunds/create': 'shopify.refund.created',
    'customers/create': 'shopify.customer.created',
    'customers/update': 'shopify.customer.updated',
    'products/update': 'shopify.product.updated',
    'app/uninstalled': 'shopify.app.uninstalled',
  }
  return mapping[topic] || `shopify.${topic.replace('/', '.')}`
}
```

### Shopify Function Implementation (Rust)

```rust
// extensions/delivery-customization/src/run.rs

use shopify_function::prelude::*;
use shopify_function::Result;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Deserialize)]
pub struct Configuration {
    pub experiment_id: String,
    pub control_rate_title: String,  // e.g., "Standard Shipping"
    pub variant_rate_title: String,  // e.g., "Express Shipping"
}

#[shopify_function_target(query_path = "src/run.graphql", schema_path = "schema.graphql")]
fn run(input: input::ResponseData) -> Result<output::FunctionRunResult> {
    let config: Configuration = match input.delivery_customization.metafield {
        Some(ref metafield) => serde_json::from_str(&metafield.value)?,
        None => return Ok(output::FunctionRunResult { operations: vec![] }),
    };

    // Get visitor assignment from cart attribute
    let assignment = input.cart.attribute
        .iter()
        .find(|a| a.key == "_ab_test_assignment")
        .and_then(|a| a.value.as_ref())
        .and_then(|v| serde_json::from_str::<VisitorAssignment>(v).ok());

    // Determine which variant this visitor is in
    let is_control = match assignment {
        Some(a) if a.experiment_id == config.experiment_id => a.variant == "control",
        _ => true // Default to control if no assignment
    };

    // Build operations based on variant
    let mut operations = vec![];

    for group in &input.cart.delivery_groups {
        for option in &group.delivery_options {
            let should_hide = if is_control {
                // Control: hide variant rate
                option.title.as_ref().map_or(false, |t| t == &config.variant_rate_title)
            } else {
                // Variant: hide control rate
                option.title.as_ref().map_or(false, |t| t == &config.control_rate_title)
            };

            if should_hide {
                operations.push(output::Operation::Hide(output::HideOperation {
                    delivery_option_handle: option.handle.clone(),
                }));
            }
        }
    }

    Ok(output::FunctionRunResult { operations })
}
```

### Web Pixel Extension Pattern

```typescript
// extensions/web-pixel/src/index.ts

import { register, analytics } from '@shopify/web-pixels-extension'

register(({ analytics, browser, settings, init }) => {
  // Get tenant config from settings
  const { ga4MeasurementId, metaPixelId, tenantId } = settings

  // Session stitching: capture from cart attributes
  let sessionData: SessionData | null = null

  // Subscribe to checkout events
  analytics.subscribe('checkout_started', async (event) => {
    // Extract session data from cart attributes
    sessionData = extractSessionData(event.data.checkout)

    // Send to GA4
    if (ga4MeasurementId && sessionData?.ga4ClientId) {
      await sendGA4Event({
        measurementId: ga4MeasurementId,
        clientId: sessionData.ga4ClientId,
        events: [{
          name: 'begin_checkout',
          params: {
            currency: event.data.checkout.currencyCode,
            value: parseFloat(event.data.checkout.totalPrice.amount),
            items: mapLineItems(event.data.checkout.lineItems)
          }
        }]
      })
    }

    // Send to Meta CAPI
    if (metaPixelId && sessionData?.metaFbp) {
      await sendMetaCAPIEvent({
        pixelId: metaPixelId,
        event: 'InitiateCheckout',
        userData: {
          fbp: sessionData.metaFbp,
          fbc: sessionData.metaFbc,
          email: hashForMeta(event.data.checkout.email),
          phone: hashForMeta(event.data.checkout.phone)
        },
        customData: {
          currency: event.data.checkout.currencyCode,
          value: parseFloat(event.data.checkout.totalPrice.amount),
          contents: mapContentsForMeta(event.data.checkout.lineItems)
        }
      })
    }
  })

  analytics.subscribe('checkout_completed', async (event) => {
    const orderId = event.data.checkout.order?.id

    // GA4 purchase event
    if (ga4MeasurementId && sessionData?.ga4ClientId) {
      await sendGA4Event({
        measurementId: ga4MeasurementId,
        clientId: sessionData.ga4ClientId,
        events: [{
          name: 'purchase',
          params: {
            transaction_id: orderId,
            currency: event.data.checkout.currencyCode,
            value: parseFloat(event.data.checkout.totalPrice.amount),
            tax: parseFloat(event.data.checkout.totalTax?.amount || '0'),
            shipping: parseFloat(event.data.checkout.shippingLine?.price?.amount || '0'),
            items: mapLineItems(event.data.checkout.lineItems)
          }
        }]
      })
    }

    // Meta CAPI Purchase event
    if (metaPixelId && sessionData) {
      await sendMetaCAPIEvent({
        pixelId: metaPixelId,
        event: 'Purchase',
        userData: {
          fbp: sessionData.metaFbp,
          fbc: sessionData.metaFbc,
          email: hashForMeta(event.data.checkout.email),
          phone: hashForMeta(event.data.checkout.phone),
          externalId: hashForMeta(event.data.checkout.order?.customer?.id)
        },
        customData: {
          currency: event.data.checkout.currencyCode,
          value: parseFloat(event.data.checkout.totalPrice.amount),
          contents: mapContentsForMeta(event.data.checkout.lineItems),
          orderId
        }
      })
    }
  })
})

// Extract session data from cart attributes
function extractSessionData(checkout: Checkout): SessionData | null {
  const attributes = checkout.customAttributes || []

  return {
    ga4ClientId: findAttribute(attributes, '_ga4_client_id'),
    ga4SessionId: findAttribute(attributes, '_ga4_session_id'),
    metaFbp: findAttribute(attributes, '_meta_fbp'),
    metaFbc: findAttribute(attributes, '_meta_fbc'),
    abTestAssignment: findAttribute(attributes, '_ab_test_assignment')
  }
}
```

### Shopify Integration Anti-Patterns

```typescript
// ‚ùå NEVER - Store tokens in plaintext
await sql`INSERT INTO shopify_credentials (access_token) VALUES (${accessToken})`

// ‚úÖ ALWAYS - Encrypt with tenant-specific key
const encrypted = await encryptToken(accessToken, tenantId)
await sql`INSERT INTO shopify_credentials (access_token_encrypted) VALUES (${encrypted})`

// ‚ùå NEVER - Skip HMAC verification for webhooks
const payload = await request.json()
await handleWebhookPayload(payload)

// ‚úÖ ALWAYS - Verify HMAC before processing
const isValid = verifyHmac(body, hmac, secret)
if (!isValid) throw new Error('Invalid webhook signature')

// ‚ùå NEVER - Process webhooks synchronously
export async function handleWebhook(req: Request) {
  const data = await req.json()
  await processOrder(data) // Blocks response!
  return Response.json({ ok: true })
}

// ‚úÖ ALWAYS - Queue for background processing
export async function handleWebhook(req: Request) {
  const data = await req.json()
  await jobProvider.send('shopify.order.created', { tenantId, data })
  return Response.json({ ok: true }) // Return immediately
}

// ‚ùå NEVER - Use environment variables for per-tenant credentials
const accessToken = process.env.SHOPIFY_ACCESS_TOKEN // Only works for one store!

// ‚úÖ ALWAYS - Get credentials from database with tenant context
const creds = await getShopifyCredentials(tenantId)
const accessToken = creds.accessToken

// ‚ùå NEVER - Cache shop credentials globally
const cache = new Map<string, Credentials>()
cache.set(shopDomain, credentials)

// ‚úÖ ALWAYS - Use tenant-scoped cache keys
await redis.set(`tenant:${tenantId}:shopify:${shopDomain}`, credentials, 'EX', 3600)

// ‚ùå NEVER - Skip tenant lookup for webhooks
const data = await request.json()
await createOrder(data) // Which tenant?!

// ‚úÖ ALWAYS - Route webhook to tenant first
const tenantId = await getTenantByShopDomain(shopDomain)
await withTenant(tenantId, () => createOrder(tenantId, data))

// ‚ùå NEVER - Hardcode Shopify scopes
const scopes = 'read_orders,write_orders'

// ‚úÖ ALWAYS - Use comprehensive scope list from app configuration
// Scopes defined in shopify.app.toml and validated during install
```

### Shopify Scopes Reference

The multi-tenant Shopify App requires comprehensive scopes for all platform features:

```toml
# shopify.app.toml
scopes = """
  read_orders, write_orders,
  read_customers, write_customers,
  read_products, write_products,
  read_inventory, write_inventory,
  read_fulfillments, write_fulfillments,
  read_shipping, write_shipping,
  read_discounts, write_discounts,
  read_price_rules, write_price_rules,
  read_draft_orders, write_draft_orders,
  read_checkouts, write_checkouts,
  read_gift_cards, write_gift_cards,
  read_content, write_content,
  read_themes,
  read_locales,
  read_markets,
  read_analytics,
  read_reports,
  read_publications,
  read_locations,
  read_merchant_managed_fulfillment_orders, write_merchant_managed_fulfillment_orders,
  read_third_party_fulfillment_orders, write_third_party_fulfillment_orders,
  read_assigned_fulfillment_orders, write_assigned_fulfillment_orders,
  read_customer_events,
  write_pixels
"""
```

---

## Now: Start Reading

1. **Read PLAN.md** - Master plan and goals
2. **Read TENANT-ISOLATION.md** - **MANDATORY** isolation rules
3. **Read your assigned phase doc** - Specific deliverables

```
Read file_path="/Users/holdenthemic/Documents/cgk/MULTI-TENANT-PLATFORM-PLAN/PLAN.md"
Read file_path="/Users/holdenthemic/Documents/cgk/MULTI-TENANT-PLATFORM-PLAN/TENANT-ISOLATION.md"
```

Then read INDEX.md for the phase structure and your specific reading list.
